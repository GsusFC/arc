<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metaballs - SVG Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'JetBrains Mono', monospace;
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            color: #ffffff;
        }
        
        canvas {
            display: block;
            background-color: #000000;
            cursor: pointer;
        }
        
        .floating-controls {
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .floating-controls h3 {
            text-shadow: 1px 1px 3px rgba(0,0,0,0.9);
        }
        
        /* Estilos para sliders */
        .slider::-webkit-slider-thumb {
            appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 2px;
            background: #00ff00;
            cursor: pointer;
            border: 1px solid #ffffff;
            box-shadow: none;
        }
        
        .slider::-moz-range-thumb {
            height: 16px;
            width: 16px;
            border-radius: 2px;
            background: #00ff00;
            cursor: pointer;
            border: 1px solid #ffffff;
            box-shadow: none;
        }
        
        .slider {
            background: #333333 !important;
            border: 1px solid #ffffff;
        }
        
        /* Checkbox terminal style */
        .terminal-checkbox {
            appearance: none;
            width: 16px;
            height: 16px;
            border: 1px solid #ffffff;
            background: #000000;
            position: relative;
            cursor: pointer;
        }
        
        .terminal-checkbox:checked {
            background: #00ff00;
        }
        
        .terminal-checkbox:checked::after {
            content: '‚úì';
            position: absolute;
            top: -2px;
            left: 2px;
            color: #000000;
            font-size: 12px;
            font-weight: bold;
        }
        
        /* Botones */
        .btn {
            padding: 8px 12px;
            border: 1px solid #ffffff;
            background: #000000;
            color: #ffffff;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn:hover {
            background: #333333;
        }
        
        .btn.active {
            background: #00ff00;
            color: #000000;
        }
        
        .btn.danger {
            border-color: #ff0000;
            color: #ff0000;
        }
        
        .btn.danger:hover {
            background: #ff0000;
            color: #ffffff;
        }

        /* Navigation button styles */
        .nav-button {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 20;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #ffffff;
            padding: 8px 12px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: #ffffff;
            text-decoration: none;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .nav-button:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: #ff6b35;
            color: #ff6b35;
        }

        .version-indicator {
            position: absolute;
            top: -8px;
            right: -8px;
            background: #ff6b35;
            color: #000000;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
    </style>
</head>
<body class="bg-black text-white">
    <!-- Version Navigation -->
    <div class="fixed top-4 right-4 z-20 flex flex-col space-y-2">
        <div class="px-3 py-2 bg-black border border-white text-center">
            <div class="text-xs text-green-400 font-medium">üé® SVG EDITOR</div>
        </div>
        
        <!-- Quick Switch -->
        <div class="flex space-x-1">
            <button onclick="window.location.href='index.html'" 
                    class="px-2 py-1 bg-black border border-blue-400 text-blue-400 text-xs hover:bg-blue-400 hover:text-black transition-all" 
                    title="Canvas Dynamic">
                üé®
            </button>
            <button onclick="window.location.href='svg-version.html'" 
                    class="px-2 py-1 bg-black border border-purple-400 text-purple-400 text-xs hover:bg-purple-400 hover:text-black transition-all" 
                    title="SVG Static">
                üì•
            </button>
            <button onclick="window.location.href='shape-editor.html'" 
                    class="px-2 py-1 bg-black border border-yellow-400 text-yellow-400 text-xs hover:bg-yellow-400 hover:text-black transition-all" 
                    title="Shape Editor">
                üõ†Ô∏è
            </button>
        </div>
    </div>
    
    <!-- Controles Flotantes -->
    <div class="fixed top-4 left-4 z-10 floating-controls" style="font-family: 'JetBrains Mono', monospace;">
        <div class="flex flex-col space-y-4">
            
            <!-- Modo de Edici√≥n -->
            <div class="flex flex-col space-y-2">
                <h3 class="text-sm font-medium text-white">edit_mode</h3>
                <div class="flex space-x-2">
                    <button id="selectMode" class="btn active">SELECT</button>
                    <button id="connectMode" class="btn">CONNECT</button>
                </div>
                <div class="text-center">
                    <span class="text-xs text-green-400" id="modeStatus">select_balls</span>
                </div>

            </div>
            
            <!-- Control de Tama√±o de Bola Seleccionada -->
            <div class="flex flex-col space-y-3">
                <h3 class="text-sm font-medium text-white">ball_size</h3>
                <div class="flex items-center space-x-3">
                    <span class="text-xs text-white">0</span>
                    <input 
                        type="range" 
                        id="ballSizeSlider" 
                        min="0" 
                        max="100" 
                        step="1" 
                        value="30"
                        class="flex-1 h-2 appearance-none cursor-pointer slider"
                        disabled
                    >
                    <span class="text-xs text-white">100</span>
                </div>
                <div class="text-center">
                    <span class="text-xs text-green-400 font-medium" id="ballSizeValue">30</span>
                </div>

            </div>
            
            <!-- Factor de Conexi√≥n Global -->
            <div class="flex flex-col space-y-3">
                <h3 class="text-sm font-medium text-white">connection_factor</h3>
                <div class="flex items-center space-x-3">
                    <span class="text-xs text-white">0.5</span>
                    <input 
                        type="range" 
                        id="connectionSlider" 
                        min="0.5" 
                        max="5.0" 
                        step="0.1" 
                        value="4.0"
                        class="flex-1 h-2 appearance-none cursor-pointer slider"
                    >
                    <span class="text-xs text-white">5.0</span>
                </div>
                <div class="text-center">
                    <span class="text-xs text-green-400 font-medium" id="connectionValue">1.0</span>
                </div>
            </div>
            
            <!-- Conexiones -->
            <div class="flex flex-col space-y-2">
                <h3 class="text-sm font-medium text-white">connections</h3>
                <div class="flex space-x-2">
                    <button id="clearConnections" class="btn danger">CLEAR ALL</button>
                </div>
                <div class="text-center">
                    <span class="text-xs text-green-400" id="connectionsCount">0 connections</span>
                </div>
            </div>
            
            <!-- Tama√±o de Grid -->
            <div class="flex flex-col space-y-3">
                <h3 class="text-sm font-medium text-white">grid_size</h3>
                <div class="flex items-center space-x-3 justify-center">
                    <div class="flex flex-col items-center space-y-1">
                        <label class="text-xs text-white">rows</label>
                        <input 
                            type="number" 
                            id="gridRowsInput" 
                            min="3" 
                            max="12" 
                            value="5"
                            class="w-12 h-8 bg-black border border-white text-center text-xs text-white"
                        >
                    </div>
                    <span class="text-white">√ó</span>
                    <div class="flex flex-col items-center space-y-1">
                        <label class="text-xs text-white">cols</label>
                        <input 
                            type="number" 
                            id="gridColsInput" 
                            min="3" 
                            max="12" 
                            value="5"
                            class="w-12 h-8 bg-black border border-white text-center text-xs text-white"
                        >
                    </div>
                </div>
                <div class="text-center">
                    <span class="text-xs text-green-400 font-medium" id="gridSizeValue">5√ó5 = 25</span>
                </div>
            </div>
            

            <!-- Advanced Controls -->
            <div class="flex flex-col space-y-2">
                <h3 class="text-sm font-medium text-white">advanced_controls</h3>
                <div class="text-xs text-gray-400 space-y-1">
                    <div>‚Ä¢ <span class="text-white">Click:</span> select_ball</div>
                    <div>‚Ä¢ <span class="text-white">Ctrl + Click:</span> multi_select</div>
                    <div>‚Ä¢ <span class="text-white">Shift + Click:</span> range_select</div>
                    <div>‚Ä¢ <span class="text-white">Ctrl + A:</span> select_all</div>
                    <div>‚Ä¢ <span class="text-white">Escape:</span> deselect_all</div>
                    <div>‚Ä¢ <span class="text-white">Space + Click:</span> quick_toggle</div>
                    <div>‚Ä¢ <span class="text-white">Scroll on ball:</span> resize</div>
                    <div>‚Ä¢ <span class="text-white">Scroll (multi):</span> group_resize</div>
                    <div>‚Ä¢ <span class="text-white">Scroll (connect):</span> factor</div>
                </div>
            </div>
            
            <!-- Acciones -->
            <div class="flex flex-col space-y-2">
                <h3 class="text-sm font-medium text-white">actions</h3>
                <div class="flex flex-col space-y-1">
                    <button id="downloadSvg" class="btn success" style="background: #000000; border: 1px solid #00ff00; color: #00ff00;">DOWNLOAD SVG</button>
                    <button id="resetAll" class="btn danger">RESET ALL</button>
                </div>
            </div>
            
        </div>
    </div>
    
    <!-- SVG Container -->
    <svg id="svg" style="display: block; background-color: #000000; width: 100vw; height: 100vh;">
        <defs>
            <filter id="glow">
                <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
                <feMerge>
                    <feMergeNode in="coloredBlur"/>
                    <feMergeNode in="SourceGraphic"/>
                </feMerge>
            </filter>
        </defs>
    </svg>
    
    <script>
        // Variables globales
        const svg = document.getElementById('svg');
        const svgNS = 'http://www.w3.org/2000/svg';
        
        let circles = [];
        let gridCountX = 5, gridCountY = 5;
        let baseRadius = 30;
        let connectionFactor = 4.0;
        let selectedCircles = [];
        let connections = [];
        let editMode = 'select';
        let connectingFrom = null;
        let spacing = 120;
        
        class Circle {
            constructor(x, y, radius, gridI, gridJ) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.gridI = gridI;
                this.gridJ = gridJ;
                this.isSelected = false;
                this.isHovered = false;
            }
            
            contains(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance <= Math.max(this.radius, 15); // M√≠nimo 15px para selecci√≥n
            }
            
            draw() {
                // C√≠rculo principal
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
                ctx.fill();
                
                // Borde si est√° seleccionado
                if (this.isSelected) {
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([]);
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius + 3, 0, 2 * Math.PI);
                    ctx.stroke();
                }
                
                // Borde si est√° siendo hover
                if (this.isHovered && !this.isSelected) {
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([]);
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius + 2, 0, 2 * Math.PI);
                    ctx.stroke();
                }
            }
        }
        
        // Funci√≥n para crear conexi√≥n entre dos c√≠rculos
        function connectCircles(c1, c2) {
            const r1 = Math.max(0, c1.radius);
            const r2 = Math.max(0, c2.radius);
            const d = Math.sqrt((c1.x - c2.x) ** 2 + (c1.y - c2.y) ** 2);
            
            console.log('üîç Validando condiciones:');
            console.log('  r1:', r1, 'r2:', r2);
            console.log('  d:', d, 'threshold:', (r1 + r2) * connectionFactor);
            console.log('  Math.abs(r1 - r2):', Math.abs(r1 - r2));
            
            const condition1 = d > (r1 + r2) * connectionFactor;
            const condition2 = d <= Math.abs(r1 - r2);
            const condition3 = r1 === 0;
            const condition4 = r2 === 0;
            
            console.log('  Condici√≥n 1 (d > threshold):', condition1);
            console.log('  Condici√≥n 2 (d <= |r1-r2|):', condition2);
            console.log('  Condici√≥n 3 (r1 === 0):', condition3);
            console.log('  Condici√≥n 4 (r2 === 0):', condition4);
            
            if (condition1 || condition2 || condition3 || condition4) {
                console.log('‚ùå SE SALE por condici√≥n:', {
                    distanciaMuyGrande: condition1,
                    distanciaMuyPeque√±a: condition2, 
                    radio1Cero: condition3,
                    radio2Cero: condition4
                });
                return;
            }
            
            console.log('‚úÖ Todas las condiciones pasaron, procediendo al renderizado');
            
            // F√≥rmula original de metaballs del script de Adobe Illustrator
            // Aplicar el connection_factor para mayor variabilidad en la forma
            const connectionInfluence = Math.pow(connectionFactor / 4.0, 1.5); // Normalizar y aplicar potencia
            const adjustedR1 = r1 * (0.7 + connectionInfluence * 0.6); // Entre 70% y 130%
            const adjustedR2 = r2 * (0.7 + connectionInfluence * 0.6);
            
            const centerAngle = Math.PI / 2; // 90 grados como en el script original
            const ot1 = Math.atan2(c2.y - c1.y, c2.x - c1.x);
            const ot2 = ot1 + Math.PI;
            
            // Ecuaci√≥n cuadr√°tica para calcular r (usando radios ajustados)
            const cos_ca = Math.cos(centerAngle);
            const a_coef = 2 - 2 * cos_ca;
            const b_coef = 2 * (1 - cos_ca) * (adjustedR1 + adjustedR2);
            const c_coef = adjustedR1 * adjustedR1 + adjustedR2 * adjustedR2 - d * d - 2 * adjustedR1 * adjustedR2 * cos_ca;
            
            console.log('Coeficientes ecuaci√≥n:', { a_coef, b_coef, c_coef });
            
            // Resolver ecuaci√≥n cuadr√°tica directamente
            let quad_a = a_coef;
            let quad_b = b_coef;
            let quad_c = c_coef;
            let r = null;
            
            if (quad_a === 0) {
                if (quad_b !== 0) {
                    const s = -quad_c / quad_b;
                    r = s > 0 ? s : null;
                }
            } else {
                quad_a *= 2;
                const discriminant = quad_b * quad_b - 2 * quad_a * quad_c;
                if (discriminant >= 0) {
                    const rd = Math.sqrt(discriminant);
                    if (discriminant > 0) {
                        const s1 = (-quad_b + rd) / quad_a;
                        const s2 = (-quad_b - rd) / quad_a;
                        if (s1 > 0 && s2 > 0) {
                            r = Math.min(s1, s2);
                        } else if (s1 > 0) {
                            r = s1;
                        } else if (s2 > 0) {
                            r = s2;
                        }
                    } else {
                        const s = -quad_b / quad_a;
                        r = s > 0 ? s : null;
                    }
                }
            }
            console.log('Radio calculado r:', r);
            if (r === null) {
                console.log('‚ùå No se puede resolver la ecuaci√≥n cuadr√°tica');
                return;
            }
            
            const radius_a = r1 + r;
            const radius_b = r2 + r;
            
            // C√°lculo de √°ngulos
            const cos_t1 = (radius_a * radius_a + d * d - radius_b * radius_b) / (2 * radius_a * d);
            const cos_t2 = (radius_b * radius_b + d * d - radius_a * radius_a) / (2 * radius_b * d);
            
            if (cos_t1 < -1 || cos_t1 > 1 || cos_t2 < -1 || cos_t2 > 1) {
                console.log('‚ùå Valores fuera de rango para acos');
                return;
            }
            
            const t1 = Math.acos(cos_t1);
            const t2 = Math.acos(cos_t2);
            
            if (isNaN(t1) || isNaN(t2)) {
                console.log('‚ùå √Ångulos inv√°lidos');
                return;
            }
            
            // Longitud de handles para curvas Bezier
            const h = (4 * Math.tan(centerAngle / 4) / 3) * r;
            const hpi = Math.PI / 2;
            
            // Puntos de ancla (f√≥rmula original)
            const p0_anchor = [c1.x + r1 * Math.cos(ot1 + t1), c1.y + r1 * Math.sin(ot1 + t1)];
            const p1_anchor = [c2.x + r2 * Math.cos(ot2 - t2), c2.y + r2 * Math.sin(ot2 - t2)];
            const p2_anchor = [c2.x + r2 * Math.cos(ot2 + t2), c2.y + r2 * Math.sin(ot2 + t2)];
            const p3_anchor = [c1.x + r1 * Math.cos(ot1 - t1), c1.y + r1 * Math.sin(ot1 - t1)];
            
            // Puntos de control (handles)
            const p0_right = [p0_anchor[0] + h * Math.cos(ot1 + t1 - hpi), p0_anchor[1] + h * Math.sin(ot1 + t1 - hpi)];
            const p1_left = [p1_anchor[0] + h * Math.cos(ot2 - t2 + hpi), p1_anchor[1] + h * Math.sin(ot2 - t2 + hpi)];
            const p2_right = [p2_anchor[0] + h * Math.cos(ot2 + t2 - hpi), p2_anchor[1] + h * Math.sin(ot2 + t2 - hpi)];
            const p3_left = [p3_anchor[0] + h * Math.cos(ot1 - t1 + hpi), p3_anchor[1] + h * Math.sin(ot1 - t1 + hpi)];
            
            console.log('Puntos calculados:', { p0_anchor, p1_anchor, p2_anchor, p3_anchor });
            
            // Renderizar la metaball con la f√≥rmula original
            ctx.fillStyle = '#ffffff';
            console.log('üé® Renderizando metaball con f√≥rmula original');
            
            ctx.beginPath();
            // Empezar en el primer punto de ancla
            ctx.moveTo(p0_anchor[0], p0_anchor[1]);
            
            // Primera curva Bezier: p0 -> p1
            ctx.bezierCurveTo(
                p0_right[0], p0_right[1],    // Control desde p0
                p1_left[0], p1_left[1],      // Control hacia p1  
                p1_anchor[0], p1_anchor[1]   // Destino p1
            );
            
            // L√≠nea recta a p2
            ctx.lineTo(p2_anchor[0], p2_anchor[1]);
            
            // Segunda curva Bezier: p2 -> p3
            ctx.bezierCurveTo(
                p2_right[0], p2_right[1],    // Control desde p2
                p3_left[0], p3_left[1],      // Control hacia p3
                p3_anchor[0], p3_anchor[1]   // Destino p3
            );
            
            // Cerrar el path
            ctx.closePath();
            ctx.fill();
            
            console.log('‚úÖ Metaball renderizada con f√≥rmula original');
        }
        
        // Inicializar grid de c√≠rculos
        function init() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            circles = [];
            connections = [];
            selectedCircles = [];
            
            const padding = 200;
            const availableWidth = canvas.width - padding * 2;
            const availableHeight = canvas.height - padding * 2;
            
            spacing = Math.min(availableWidth / (gridCountX - 1), availableHeight / (gridCountY - 1));
            
            const startX = (canvas.width - (gridCountX - 1) * spacing) / 2;
            const startY = (canvas.height - (gridCountY - 1) * spacing) / 2;
            
            for (let i = 0; i < gridCountX; i++) {
                for (let j = 0; j < gridCountY; j++) {
                    const x = startX + i * spacing;
                    const y = startY + j * spacing;
                    circles.push(new Circle(x, y, baseRadius, i, j));
                }
            }
            
            updateDisplays();
        }
        
        // Funci√≥n principal de dibujo
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Dibujar conexiones manuales
            if (connections.length > 0) {
                console.log('Dibujando', connections.length, 'conexiones manuales');
            }
            connections.forEach((conn, index) => {
                if (conn.from.radius > 0 && conn.to.radius > 0) {
                    console.log(`Dibujando conexi√≥n ${index + 1}:`, conn.from.gridI + '_' + conn.from.gridJ, '->', conn.to.gridI + '_' + conn.to.gridJ);
                    connectCircles(conn.from, conn.to);
                }
            });
            
            // Dibujar c√≠rculos
            circles.forEach(circle => {
                if (circle.radius > 0) {
                    circle.draw();
                }
            });
            
            // Mostrar c√≠rculo que estamos conectando
            if (editMode === 'connect' && connectingFrom) {
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(connectingFrom.x, connectingFrom.y, Math.max(connectingFrom.radius + 5, 20), 0, 2 * Math.PI);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }
        
        // Event listeners del canvas
        canvas.addEventListener('mousemove', (event) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            
            // Reset hover states
            circles.forEach(circle => circle.isHovered = false);
            
            // Find hovered circle
            const hoveredCircle = circles.find(circle => circle.contains(mouseX, mouseY));
            if (hoveredCircle) {
                hoveredCircle.isHovered = true;
            }
            
            draw();
        });
        
        canvas.addEventListener('click', (event) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            
            const clickedCircle = circles.find(circle => circle.contains(mouseX, mouseY));
            
            if (!clickedCircle) return;
            
            if (editMode === 'select') {
                // Modo selecci√≥n
                if (event.ctrlKey || event.metaKey) {
                    // Multi-selecci√≥n: toggle el estado del c√≠rculo clickeado
                    clickedCircle.isSelected = !clickedCircle.isSelected;
                    if (clickedCircle.isSelected) {
                        // A√±adir a la selecci√≥n si no est√° ya
                        if (!selectedCircles.includes(clickedCircle)) {
                            selectedCircles.push(clickedCircle);
                        }
                    } else {
                        // Remover de la selecci√≥n
                        selectedCircles = selectedCircles.filter(c => c !== clickedCircle);
                    }
                } else if (event.shiftKey && selectedCircles.length > 0) {
                    // Selecci√≥n por rango (Shift+Click)
                    const firstSelected = selectedCircles[0];
                    const startI = Math.min(firstSelected.gridI, clickedCircle.gridI);
                    const endI = Math.max(firstSelected.gridI, clickedCircle.gridI);
                    const startJ = Math.min(firstSelected.gridJ, clickedCircle.gridJ);
                    const endJ = Math.max(firstSelected.gridJ, clickedCircle.gridJ);
                    
                    // Limpiar selecci√≥n actual
                    selectedCircles.forEach(c => c.isSelected = false);
                    selectedCircles = [];
                    
                    // Seleccionar rango rectangular
                    circles.forEach(circle => {
                        if (circle.gridI >= startI && circle.gridI <= endI && 
                            circle.gridJ >= startJ && circle.gridJ <= endJ) {
                            circle.isSelected = true;
                            selectedCircles.push(circle);
                        }
                    });
                } else {
                    // Selecci√≥n simple: limpiar todo y seleccionar solo este
                    selectedCircles.forEach(c => c.isSelected = false);
                    selectedCircles = [clickedCircle];
                    clickedCircle.isSelected = true;
                }
                
                updateSelectedInfo();
                
            } else if (editMode === 'connect') {
                // Modo conexi√≥n
                if (!connectingFrom) {
                    connectingFrom = clickedCircle;
                    document.getElementById('modeStatus').textContent = 'click_target_ball';

                } else if (connectingFrom !== clickedCircle) {
                    // Verificar si ya existe la conexi√≥n
                    const existingConnection = connections.find(conn => 
                        (conn.from === connectingFrom && conn.to === clickedCircle) ||
                        (conn.from === clickedCircle && conn.to === connectingFrom)
                    );
                    
                    if (!existingConnection) {
                        connections.push({ from: connectingFrom, to: clickedCircle });
                        console.log('üîó Conexi√≥n creada!', connectingFrom.gridI + '_' + connectingFrom.gridJ, '<->', clickedCircle.gridI + '_' + clickedCircle.gridJ, 'Total:', connections.length);
                    }
                    connectingFrom = null;
                    document.getElementById('modeStatus').textContent = 'connect_balls';

                    updateDisplays();
                } else {
                    connectingFrom = null;
                    document.getElementById('modeStatus').textContent = 'connect_balls';

                }
            }
            
            draw();
        });
        
        // Funciones de actualizaci√≥n de displays
        function updateSelectedInfo() {
            const ballSizeSlider = document.getElementById('ballSizeSlider');
            
            if (selectedCircles.length === 0) {
                ballSizeSlider.disabled = true;
                ballSizeSlider.value = 30;
            } else if (selectedCircles.length === 1) {
                ballSizeSlider.disabled = false;
                ballSizeSlider.value = selectedCircles[0].radius;
            } else {
                // M√∫ltiples seleccionadas
                const avgSize = Math.round(selectedCircles.reduce((sum, c) => sum + c.radius, 0) / selectedCircles.length);
                ballSizeSlider.value = avgSize;
                ballSizeSlider.disabled = false;
            }
            
            updateBallSizeDisplay();
        }
        
        function updateDisplays() {
            document.getElementById('connectionValue').textContent = connectionFactor.toFixed(1);
            document.getElementById('gridSizeValue').textContent = `${gridCountX}√ó${gridCountY} = ${gridCountX * gridCountY}`;
            document.getElementById('connectionsCount').textContent = `${connections.length} connections`;
            updateSelectedInfo();
        }
        
        function updateBallSizeDisplay() {
            const value = document.getElementById('ballSizeSlider').value;
            document.getElementById('ballSizeValue').textContent = value;
        }
        
        // Event Listeners para controles
        document.getElementById('selectMode').addEventListener('click', () => {
            editMode = 'select';
            connectingFrom = null;
            document.getElementById('selectMode').classList.add('active');
            document.getElementById('connectMode').classList.remove('active');
            document.getElementById('modeStatus').textContent = 'select_balls';

            draw();
        });
        
        document.getElementById('connectMode').addEventListener('click', () => {
            editMode = 'connect';
            connectingFrom = null;
            document.getElementById('connectMode').classList.add('active');
            document.getElementById('selectMode').classList.remove('active');
            document.getElementById('modeStatus').textContent = 'connect_balls';
            draw();
        });
        
        document.getElementById('ballSizeSlider').addEventListener('input', (event) => {
            const newSize = parseInt(event.target.value);
            selectedCircles.forEach(circle => {
                circle.radius = newSize;
            });
            updateBallSizeDisplay();
            draw();
        });
        
        document.getElementById('connectionSlider').addEventListener('input', (event) => {
            connectionFactor = parseFloat(event.target.value);
            updateDisplays();
            draw();
        });
        
        document.getElementById('clearConnections').addEventListener('click', () => {
            connections = [];
            updateDisplays();
            draw();
        });
        
        document.getElementById('resetAll').addEventListener('click', () => {
            circles.forEach(circle => {
                circle.radius = baseRadius;
                circle.isSelected = false;
            });
            selectedCircles = [];
            connections = [];
            connectingFrom = null;
            updateDisplays();
            draw();
        });
        
        // Event listeners para grid size
        ['gridRowsInput', 'gridColsInput'].forEach(id => {
            document.getElementById(id).addEventListener('input', (event) => {
                const newValue = parseInt(event.target.value);
                if (newValue >= 3 && newValue <= 12) {
                    if (id === 'gridRowsInput') gridCountY = newValue;
                    else gridCountX = newValue;
                    init();
                }
            });
        });
        
        // === CONTROLES AVANZADOS DE MOUSE ===
        let spacePressed = false;
        let ctrlPressed = false;
        
        // Detectar teclas
        document.addEventListener('keydown', (event) => {
            if (event.code === 'Space') {
                spacePressed = true;
                event.preventDefault();
            }
            if (event.ctrlKey || event.metaKey) {
                ctrlPressed = true;
                
                // Ctrl+A / Cmd+A = Select All
                if (event.code === 'KeyA' && editMode === 'select') {
                    event.preventDefault();
                    selectedCircles.forEach(c => c.isSelected = false);
                    selectedCircles = [...circles];
                    circles.forEach(circle => circle.isSelected = true);
                    updateSelectedInfo();
                    draw();
                }
            }
            
            // Escape = Deselect All
            if (event.code === 'Escape') {
                selectedCircles.forEach(c => c.isSelected = false);
                selectedCircles = [];
                connectingFrom = null;
                updateSelectedInfo();
                draw();
            }
        });
        
        document.addEventListener('keyup', (event) => {
            if (event.code === 'Space') {
                spacePressed = false;
                event.preventDefault();
            }
            if (!event.ctrlKey && !event.metaKey) {
                ctrlPressed = false;
            }
        });
        
        // Scroll para control de valores
        canvas.addEventListener('wheel', (event) => {
            event.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            const hoveredCircle = circles.find(circle => circle.contains(mouseX, mouseY));
            
            if (hoveredCircle) {
                const delta = -event.deltaY / 100; // Normalizar scroll
                
                if (editMode === 'select') {
                    // En modo select: scroll ajusta tama√±o de la bola
                    if (spacePressed || hoveredCircle.isSelected) {
                        
                        if (selectedCircles.length > 1 && hoveredCircle.isSelected) {
                            // Si hay m√∫ltiples bolas seleccionadas y hacemos scroll sobre una de ellas,
                            // cambiar el tama√±o de TODAS las seleccionadas
                            const deltaSize = delta * 3;
                            selectedCircles.forEach(circle => {
                                const newRadius = Math.max(0, Math.min(100, circle.radius + deltaSize));
                                circle.radius = newRadius;
                            });
                            
                            // Actualizar slider con el valor de la bola sobre la que hicimos hover
                            document.getElementById('ballSizeSlider').value = hoveredCircle.radius;
                            updateBallSizeDisplay();
                            
                        } else {
                            // Comportamiento normal para una sola bola
                            const newRadius = Math.max(0, Math.min(100, hoveredCircle.radius + delta * 3));
                            hoveredCircle.radius = newRadius;
                            
                            // Actualizar slider si est√° seleccionada
                            if (hoveredCircle.isSelected) {
                                document.getElementById('ballSizeSlider').value = newRadius;
                                updateBallSizeDisplay();
                            }
                        }
                        draw();
                    }
                } else if (editMode === 'connect') {
                    // En modo connect: scroll ajusta connection factor
                    const newFactor = Math.max(0.5, Math.min(5.0, connectionFactor + delta * 0.1));
                    connectionFactor = newFactor;
                    document.getElementById('connectionSlider').value = connectionFactor;
                    updateDisplays();
                    draw();
                }
            }
        });
        
        // Click mejorado con teclas modificadoras
        canvas.addEventListener('click', (event) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            const clickedCircle = circles.find(circle => circle.contains(mouseX, mouseY));
            
            if (!clickedCircle) return;
            
            // Space + Click = Selecci√≥n r√°pida (sin cambiar modo)
            if (spacePressed) {
                clickedCircle.isSelected = !clickedCircle.isSelected;
                if (clickedCircle.isSelected) {
                    if (!selectedCircles.includes(clickedCircle)) {
                        selectedCircles.push(clickedCircle);
                    }
                } else {
                    selectedCircles = selectedCircles.filter(c => c !== clickedCircle);
                }
                updateSelectedInfo();
                draw();
                return;
            }
            
            // Ctrl/Cmd + Click en modo connect = Conexi√≥n r√°pida
            if (ctrlPressed && editMode === 'select') {
                // Cambiar temporalmente a modo connect
                if (!connectingFrom) {
                    connectingFrom = clickedCircle;
                    document.getElementById('modeStatus').textContent = 'quick_connect_mode';
                } else if (connectingFrom !== clickedCircle) {
                    const existingConnection = connections.find(conn => 
                        (conn.from === connectingFrom && conn.to === clickedCircle) ||
                        (conn.from === clickedCircle && conn.to === connectingFrom)
                    );
                    
                    if (!existingConnection) {
                        connections.push({ from: connectingFrom, to: clickedCircle });
                    }
                    connectingFrom = null;
                    document.getElementById('modeStatus').textContent = 'select_balls';
                    updateDisplays();
                } else {
                    connectingFrom = null;
                    document.getElementById('modeStatus').textContent = 'select_balls';
                }
                draw();
                return;
            }
            
            // El resto del c√≥digo de click normal continuar√° despu√©s
        }, true); // useCapture = true para capturar antes que el evento normal
        
        // Resize handler
        window.addEventListener('resize', () => {
            init();
        });
        
        // Funci√≥n para generar y descargar SVG
        function downloadSVG() {
            const svgWidth = canvas.width;
            const svgHeight = canvas.height;
            
            let svgContent = `<svg width="${svgWidth}" height="${svgHeight}" xmlns="http://www.w3.org/2000/svg" style="background: black;">`;
            
            // Agregar c√≠rculos visibles
            circles.forEach(circle => {
                if (circle.radius > 0) {
                    svgContent += `<circle cx="${circle.x}" cy="${circle.y}" r="${circle.radius}" fill="white" stroke="${circle.isSelected ? '#ffff00' : '#666'}" stroke-width="${circle.isSelected ? 2 : 1}" opacity="0.8"/>`;
                }
            });
            
            // Agregar conexiones como paths
            connections.forEach(conn => {
                if (conn.from.radius > 0 && conn.to.radius > 0) {
                    const r1 = conn.from.radius;
                    const r2 = conn.to.radius;
                    const d = Math.sqrt((conn.from.x - conn.to.x) ** 2 + (conn.from.y - conn.to.y) ** 2);
                    
                    // Condici√≥n de conexi√≥n simplificada
                    if (d <= (r1 + r2) * connectionFactor && d > Math.abs(r1 - r2)) {
                        // Generar metaball simplificada como path
                        const connectionInfluence = Math.pow(connectionFactor / 4.0, 1.5);
                        const adjustedR1 = r1 * (0.7 + connectionInfluence * 0.6);
                        const adjustedR2 = r2 * (0.7 + connectionInfluence * 0.6);
                        
                        // Calcular puntos de control para metaball
                        const angle = Math.atan2(conn.to.y - conn.from.y, conn.to.x - conn.from.x);
                        const controlDist = d * 0.3;
                        
                        const p1x = conn.from.x + Math.cos(angle - Math.PI/2) * adjustedR1;
                        const p1y = conn.from.y + Math.sin(angle - Math.PI/2) * adjustedR1;
                        const p2x = conn.to.x + Math.cos(angle - Math.PI/2) * adjustedR2;
                        const p2y = conn.to.y + Math.sin(angle - Math.PI/2) * adjustedR2;
                        const p3x = conn.to.x + Math.cos(angle + Math.PI/2) * adjustedR2;
                        const p3y = conn.to.y + Math.sin(angle + Math.PI/2) * adjustedR2;
                        const p4x = conn.from.x + Math.cos(angle + Math.PI/2) * adjustedR1;
                        const p4y = conn.from.y + Math.sin(angle + Math.PI/2) * adjustedR1;
                        
                        const c1x = p1x + Math.cos(angle) * controlDist;
                        const c1y = p1y + Math.sin(angle) * controlDist;
                        const c2x = p2x - Math.cos(angle) * controlDist;
                        const c2y = p2y - Math.sin(angle) * controlDist;
                        const c3x = p3x - Math.cos(angle) * controlDist;
                        const c3y = p3y - Math.sin(angle) * controlDist;
                        const c4x = p4x + Math.cos(angle) * controlDist;
                        const c4y = p4y + Math.sin(angle) * controlDist;
                        
                        svgContent += `<path d="M ${p1x} ${p1y} C ${c1x} ${c1y} ${c2x} ${c2y} ${p2x} ${p2y} L ${p3x} ${p3y} C ${c3x} ${c3y} ${c4x} ${c4y} ${p4x} ${p4y} Z" fill="white" opacity="0.9"/>`;
                    }
                }
            });
            
            svgContent += '</svg>';
            
            // Crear blob y descargar
            const blob = new Blob([svgContent], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `metaballs-creation-${Date.now()}.svg`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // Event listener para descarga
        document.getElementById('downloadSvg').addEventListener('click', downloadSVG);
        
        // Inicializar
        init();
        draw();
        
    </script>
</body>
</html>
