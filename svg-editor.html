<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metaballs - SVG Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'JetBrains Mono', monospace;
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            color: #ffffff;
        }
        
        .floating-controls {
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .floating-controls h3 {
            text-shadow: 1px 1px 3px rgba(0,0,0,0.9);
        }
        
        /* Estilos para sliders */
        .slider::-webkit-slider-thumb {
            appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 2px;
            background: #00ff00;
            cursor: pointer;
            border: 1px solid #ffffff;
            box-shadow: none;
        }
        
        .slider::-moz-range-thumb {
            height: 16px;
            width: 16px;
            border-radius: 2px;
            background: #00ff00;
            cursor: pointer;
            border: 1px solid #ffffff;
            box-shadow: none;
        }
        
        .slider {
            background: #333333 !important;
            border: 1px solid #ffffff;
        }
        
        /* Checkbox terminal style */
        .terminal-checkbox {
            appearance: none;
            width: 16px;
            height: 16px;
            border: 1px solid #ffffff;
            background: #000000;
            position: relative;
            cursor: pointer;
        }
        
        .terminal-checkbox:checked {
            background: #00ff00;
        }
        
        .terminal-checkbox:checked::after {
            content: '‚úì';
            position: absolute;
            top: -2px;
            left: 2px;
            color: #000000;
            font-size: 12px;
            font-weight: bold;
        }
        
        /* Botones */
        .btn {
            padding: 8px 12px;
            border: 1px solid #ffffff;
            background: #000000;
            color: #ffffff;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn:hover {
            background: #333333;
        }
        
        .btn.active {
            background: #00ff00;
            color: #000000;
        }
        
        .btn.danger {
            border-color: #ff0000;
            color: #ff0000;
        }
        
        .btn.danger:hover {
            background: #ff0000;
            color: #ffffff;
        }

        /* Navigation button styles */
        .nav-button {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 20;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #ffffff;
            padding: 8px 12px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: #ffffff;
            text-decoration: none;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .nav-button:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: #ff6b35;
            color: #ff6b35;
        }

        .version-indicator {
            position: absolute;
            top: -8px;
            right: -8px;
            background: #ff6b35;
            color: #000000;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        input[type="number"], input[type="number"]:not(:disabled):not([readonly]) {
    color: #fff !important;
    background: #000 !important;
    caret-color: #fff !important;
    border-color: #fff !important;
    text-shadow: 0 0 0 #fff;
}
        input[type="number"]::placeholder {
            color: #aaa !important;
            opacity: 1;
        }
        input[type="number"]:-webkit-autofill {
            -webkit-text-fill-color: #fff !important;
            box-shadow: 0 0 0 1000px #000 inset !important;
        }
    </style>
</head>
<body class="bg-black text-white">
    <!-- Version Navigation -->
    <div class="fixed top-4 right-4 z-20 flex flex-col space-y-2">
        <div class="px-3 py-2 bg-black border border-white text-center">
            <div class="text-xs text-green-400 font-medium">üé® SVG EDITOR</div>
        </div>
        
        <!-- Quick Switch -->
        <div class="flex space-x-1">
            <button onclick="window.location.href='index.html'" 
                    class="px-2 py-1 bg-black border border-blue-400 text-blue-400 text-xs hover:bg-blue-400 hover:text-black transition-all" 
                    title="Canvas Dynamic">
                üé®
            </button>
            <button onclick="window.location.href='svg-version.html'" 
                    class="px-2 py-1 bg-black border border-purple-400 text-purple-400 text-xs hover:bg-purple-400 hover:text-black transition-all" 
                    title="SVG Static">
                üì•
            </button>
            <button onclick="window.location.href='svg-editor.html'" 
                    class="px-2 py-1 bg-black border border-green-400 text-green-400 text-xs hover:bg-green-400 hover:text-black transition-all" 
                    title="SVG Editor">
                üé®
            </button>
        </div>
    </div>
    
    <!-- Panel lateral flotante contextual -->
    <div class="fixed top-4 left-4 z-10 w-80 max-w-full flex flex-col gap-5 p-4 bg-black/80 rounded-xl shadow-xl" aria-label="Controles de edici√≥n metaballs">
        <!-- Modo de edici√≥n -->
        <section class="flex flex-col gap-2 border-b border-white/20 pb-3">
            <h2 class="text-xs font-bold uppercase tracking-wide text-green-400">Modo de edici√≥n</h2>
            <div class="flex gap-2">
                <button id="selectMode" class="btn w-1/2 uppercase font-semibold text-xs px-3 py-1 rounded border border-white transition focus:outline-none focus:ring-2 focus:ring-green-400 active" aria-label="Modo seleccionar">SELECT</button>
                <button id="connectMode" class="btn w-1/2 uppercase font-semibold text-xs px-3 py-1 rounded border border-white transition focus:outline-none focus:ring-2 focus:ring-green-400" aria-label="Modo conectar">CONNECT</button>
            </div>
            
        </section>

        <!-- Configuraci√≥n de bolas (solo en SELECT) -->
        <section id="ballControls" class="flex flex-col gap-2 border-b border-white/20 pb-3" hidden>
            <h2 class="text-xs font-bold uppercase tracking-wide text-blue-400">Bola seleccionada</h2>
            <div class="flex items-center gap-3">
                <span class="text-xs">Tama√±o</span>
                <input id="ballSizeSlider" type="range" min="0" max="100" step="1" class="flex-1" />
                <input id="ballSizeInput" type="number" min="0" max="100" step="1" class="w-16 text-xs text-center bg-black border border-white text-white rounded focus:outline-none focus:ring-2 focus:ring-green-400" aria-label="Tama√±o de bola" />
            </div>
        </section>

        <!-- Configuraci√≥n de conexiones (solo en CONNECT) -->
        <section id="connectionControls" class="flex flex-col gap-2 border-b border-white/20 pb-3" hidden>
            <h2 class="text-xs font-bold uppercase tracking-wide text-pink-400">Conexiones</h2>
            <div class="flex gap-2 justify-between">
    <button id="globalMode" class="btn uppercase font-semibold text-xs px-3 py-1 rounded border border-white transition focus:outline-none focus:ring-2 focus:ring-pink-400">GLOBAL</button>
    <button id="individualMode" class="btn uppercase font-semibold text-xs px-3 py-1 rounded border border-white transition focus:outline-none focus:ring-2 focus:ring-pink-400">INDIVIDUAL</button>
</div>
<div id="connectionSliderBlock" class="flex items-center gap-3" hidden>
    <span class="text-xs">Factor</span>
    <input id="connectionSlider" type="range" min="0.1" max="8.0" step="0.05" class="flex-1" />
    <input id="connectionInput" type="number" min="0.1" max="8.0" step="0.05" class="w-16 text-xs text-center bg-black border border-white text-white rounded focus:outline-none focus:ring-2 focus:ring-pink-400" aria-label="Factor de conexi√≥n" />
</div>
<div id="bridgeWidthBlock" class="flex items-center gap-3">
    <span class="text-xs">Bridge width</span>
    <input id="bridgeWidthSlider" type="range" min="1.0" max="4.0" step="0.1" class="flex-1" />
    <input id="bridgeWidthInput" type="number" min="1.0" max="4.0" step="0.1" class="w-16 text-xs text-center bg-black border border-white text-white rounded focus:outline-none focus:ring-2 focus:ring-pink-400" aria-label="Grosor del puente" />
</div>
<span id="connectionsCount" class="text-xs text-green-400"></span>
            
<button id="clearConnections" class="btn danger mt-2 uppercase font-semibold text-xs px-3 py-1 rounded border border-red-500 transition focus:outline-none focus:ring-2 focus:ring-red-400">CLEAR ALL</button>
</section>

<!-- Configuraci√≥n de grid (siempre visible) -->
<section class="flex flex-col gap-2 border-b border-white/20 pb-3">
    <h2 class="text-xs font-bold uppercase tracking-wide text-yellow-400">Grid</h2>
    <div class="flex items-center gap-2">
        <label class="text-xs">Filas</label>
        <input id="gridRowsInput" type="number" min="3" max="12" value="5" class="w-12 text-xs text-center bg-black border border-white text-white rounded focus:outline-none focus:ring-2 focus:ring-yellow-400" aria-label="Filas del grid" />
        <span class="text-xs">√ó</span>
        <label class="text-xs">Cols</label>
        <input id="gridColsInput" type="number" min="3" max="12" value="5" class="w-12 text-xs text-center bg-black border border-white text-white rounded focus:outline-none focus:ring-2 focus:ring-yellow-400" aria-label="Columnas del grid" />
        <span id="gridSizeValue" class="text-xs text-green-400 ml-2"></span>
    </div>
</section>

        <!-- Acciones -->
        <section class="flex flex-col gap-2">
            <div class="flex gap-2">
                <button id="downloadSVG" class="btn flex-1 border-green-400 text-green-400 uppercase font-semibold text-xs px-3 py-1 rounded border transition focus:outline-none focus:ring-2 focus:ring-green-400">üì• EXPORTAR SVG</button>
                <button id="resetAll" class="btn danger flex-1 uppercase font-semibold text-xs px-3 py-1 rounded border border-red-500 transition focus:outline-none focus:ring-2 focus:ring-red-400">RESET</button>
            </div>
            <button id="showHelp" class="btn text-xs mt-1 uppercase font-semibold px-3 py-1 rounded border border-white transition focus:outline-none focus:ring-2 focus:ring-yellow-400" aria-label="Mostrar ayuda y atajos">‚ùì AYUDA / ATAJOS</button>
        </section>
    </div>

    <!-- Modal de ayuda -->
    <div id="helpModal" class="fixed inset-0 bg-black/70 flex items-center justify-center z-50" style="display:none;" role="dialog" aria-modal="true" aria-label="Ayuda y atajos">
        <div class="bg-black border border-white rounded-lg p-6 max-w-md w-full shadow-2xl relative">
            <button id="closeHelp" class="absolute top-2 right-2 text-white text-lg" aria-label="Cerrar ayuda">&times;</button>
            <h2 class="text-lg font-bold mb-4 text-green-400">Atajos y controles avanzados</h2>
            <ul class="text-xs space-y-1 text-gray-200">
                <li><b>Click</b>: seleccionar bola/conexi√≥n</li>
                <li><b>Ctrl + Click</b>: multi-selecci√≥n</li>
                <li><b>Esc</b>: deseleccionar todo / cerrar modal</li>
                <li><b>Ctrl + A</b>: seleccionar todo</li>
                <li><b>Space + Click</b>: alternar selecci√≥n r√°pida</li>
                <li><b>Scroll</b>: cambiar tama√±o/factor seg√∫n contexto</li>
            </ul>
        </div>
    </div>

    <!-- SVG Container -->
    <svg id="svg" style="display: block; background-color: #000000; width: 100vw; height: 100vh;">
        <defs>
            <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
                <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                <feMerge>
                    <feMergeNode in="coloredBlur"/>
                    <feMergeNode in="SourceGraphic"/>
                </feMerge>
            </filter>
        </defs>
    </svg>
    
    <script>
        // Variables globales
        const svg = document.getElementById('svg');
        const svgNS = 'http://www.w3.org/2000/svg';
        
        let circles = [];
        let gridCountX = 5, gridCountY = 5;
        let baseRadius = 30;
        let connectionFactor = 4.0;
        let bridgeWidth = 2.4; // controla el grosor del puente (handleSize)
        let selectedCircles = [];
        let connections = [];
        let selectedConnections = []; // Conexiones seleccionadas para modo individual
        let connectionFactorMode = 'global'; // 'global' | 'individual'
        let editMode = 'select';
        let connectingFrom = null;
        let spacing = 120;
        let draggingFrom = null;
        let isDraggingConnect = false;
        let dragStartX = 0, dragStartY = 0;
        let mouseXGlobal = 0, mouseYGlobal = 0;
        let suppressNextClick = false;
        const DRAG_THRESHOLD_PX = 8;
        
        class Circle {
            constructor(x, y, radius, gridI, gridJ) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.gridI = gridI;
                this.gridJ = gridJ;
                this.isSelected = false;
                this.isHovered = false;
            }
            
            contains(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance <= Math.max(this.radius, 15); // M√≠nimo 15px para selecci√≥n
            }
            
            draw() {
                // C√≠rculo principal
                const circle = document.createElementNS(svgNS, 'circle');
                circle.setAttribute('cx', this.x);
                circle.setAttribute('cy', this.y);
                circle.setAttribute('r', this.radius);
                circle.setAttribute('fill', '#ffffff');
                circle.setAttribute('opacity', '1.0');
                
                // Efecto glow opcional (comentado para mayor claridad)
                // circle.setAttribute('filter', 'url(#glow)');
                
                // A√±adir al SVG
                svg.appendChild(circle);
                
                // Borde si est√° seleccionado
                if (this.isSelected) {
                    const selectedBorder = document.createElementNS(svgNS, 'circle');
                    selectedBorder.setAttribute('cx', this.x);
                    selectedBorder.setAttribute('cy', this.y);
                    selectedBorder.setAttribute('r', this.radius + 3);
                    selectedBorder.setAttribute('fill', 'none');
                    selectedBorder.setAttribute('stroke', '#00ff00');
                    selectedBorder.setAttribute('stroke-width', '1');
                    selectedBorder.setAttribute('opacity', '1');
                    svg.appendChild(selectedBorder);
                }
                
                // Borde si est√° siendo hover
                if (this.isHovered && !this.isSelected) {
                    const hoverBorder = document.createElementNS(svgNS, 'circle');
                    hoverBorder.setAttribute('cx', this.x);
                    hoverBorder.setAttribute('cy', this.y);
                    hoverBorder.setAttribute('r', this.radius + 2);
                    hoverBorder.setAttribute('fill', 'none');
                    hoverBorder.setAttribute('stroke', '#ffffff');
                    hoverBorder.setAttribute('stroke-width', '1');
                    hoverBorder.setAttribute('opacity', '0.8');
                    svg.appendChild(hoverBorder);
                }
            }
        }
        
        // Funci√≥n para detectar click en conexiones (metaballs)
        function getClickedConnection(mouseX, mouseY) {
            for (let conn of connections) {
                if (conn.from.radius > 0 && conn.to.radius > 0) {
                    const r1 = conn.from.radius;
                    const r2 = conn.to.radius;
                    // Aproximaci√≥n simple: verificar si el click est√° en la zona media entre los centros
                    const midX = (conn.from.x + conn.to.x) / 2;
                    const midY = (conn.from.y + conn.to.y) / 2;
                    const avgRadius = (r1 + r2) / 2;
                    const distanceToMid = Math.hypot(mouseX - midX, mouseY - midY);
                    const threshold = avgRadius * 0.7;
                    if (distanceToMid <= threshold * 1.5) {
                        return conn;
                    }
                }
            }
            return null;
        }
        
        // Funci√≥n para crear conexi√≥n entre dos c√≠rculos
        function connectCircles(c1, c2, connection = null) {
            const r1 = Math.max(0, c1.radius);
            const r2 = Math.max(0, c2.radius);
            const d = Math.sqrt((c1.x - c2.x) ** 2 + (c1.y - c2.y) ** 2);
            
            // Usar connectionFactor individual o global seg√∫n el modo
            const usedConnectionFactor = connection ? connection.connectionFactor : connectionFactor;
            
            console.log('üîç Validando condiciones:');
            console.log('  r1:', r1, 'r2:', r2);
            console.log('  d:', d, 'threshold:', (r1 + r2) * usedConnectionFactor);
            console.log('  usedConnectionFactor:', usedConnectionFactor, 'mode:', connectionFactorMode);
            console.log('  Math.abs(r1 - r2):', Math.abs(r1 - r2));
            
            const condition1 = d > (r1 + r2) * usedConnectionFactor;
            const condition2 = d <= Math.abs(r1 - r2);
            const condition3 = r1 === 0;
            const condition4 = r2 === 0;
            
            console.log('  Condici√≥n 1 (d > threshold):', condition1);
            console.log('  Condici√≥n 2 (d <= |r1-r2|):', condition2);
            console.log('  Condici√≥n 3 (r1 === 0):', condition3);
            console.log('  Condici√≥n 4 (r2 === 0):', condition4);
            
            if (condition1 || condition2 || condition3 || condition4) {
                console.log('‚ùå SE SALE por condici√≥n:', {
                    distanciaMuyGrande: condition1,
                    distanciaMuyPeque√±a: condition2, 
                    radio1Cero: condition3,
                    radio2Cero: condition4
                });
                return;
            }
            
            console.log('‚úÖ Todas las condiciones pasaron, procediendo al renderizado');
            
            // F√≥rmula original de metaballs del script de Adobe Illustrator
            // Aplicar el connection_factor para mayor variabilidad en la forma
            const connectionInfluence = Math.pow(usedConnectionFactor / 8.0, 0.7); // M√°s sensible y progresivo
            const adjustedR1 = r1 * (0.7 + connectionInfluence * 0.6); // Entre 70% y 130%
            const adjustedR2 = r2 * (0.7 + connectionInfluence * 0.6);
            
            const centerAngle = Math.PI / 2; // 90 grados como en el script original
            const ot1 = Math.atan2(c2.y - c1.y, c2.x - c1.x);
            const ot2 = ot1 + Math.PI;
            
            // Ecuaci√≥n cuadr√°tica para calcular r (usando radios ajustados)
            const cos_ca = Math.cos(centerAngle);
            const a_coef = 2 - 2 * cos_ca;
            const b_coef = 2 * (1 - cos_ca) * (adjustedR1 + adjustedR2);
            const c_coef = adjustedR1 * adjustedR1 + adjustedR2 * adjustedR2 - d * d - 2 * adjustedR1 * adjustedR2 * cos_ca;
            
            console.log('Coeficientes ecuaci√≥n:', { a_coef, b_coef, c_coef });
            
            // Resolver ecuaci√≥n cuadr√°tica directamente
            let quad_a = a_coef;
            let quad_b = b_coef;
            let quad_c = c_coef;
            let r = null;
            
            if (quad_a === 0) {
                if (quad_b !== 0) {
                    const s = -quad_c / quad_b;
                    r = s > 0 ? s : null;
                }
            } else {
                quad_a *= 2;
                const discriminant = quad_b * quad_b - 2 * quad_a * quad_c;
                if (discriminant >= 0) {
                    const rd = Math.sqrt(discriminant);
                    if (discriminant > 0) {
                        const s1 = (-quad_b + rd) / quad_a;
                        const s2 = (-quad_b - rd) / quad_a;
                        if (s1 > 0 && s2 > 0) {
                            r = Math.min(s1, s2);
                        } else if (s1 > 0) {
                            r = s1;
                        } else if (s2 > 0) {
                            r = s2;
                        }
                    } else {
                        const s = -quad_b / quad_a;
                        r = s > 0 ? s : null;
                    }
                }
            }
            console.log('Radio calculado r:', r);
            if (r === null) {
                console.log('‚ùå No se puede resolver la ecuaci√≥n cuadr√°tica');
                return;
            }
            
            const radius_a = r1 + r;
            const radius_b = r2 + r;
            
            // C√°lculo de √°ngulos
            const cos_t1 = (radius_a * radius_a + d * d - radius_b * radius_b) / (2 * radius_a * d);
            const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
            const maxSpread = Math.acos(clamp((r1 - r2) / d, -1, 1));
            const u1 = Math.acos(clamp((r1*r1 + d*d - r2*r2) / (2 * r1 * d), -1, 1));
            const u2 = Math.acos(clamp((r2*r2 + d*d - r1*r1) / (2 * r2 * d), -1, 1));
            
            if (!Number.isFinite(u1) || !Number.isFinite(u2)) return;
            
            const angle1 = angleBetweenCenters + u1 + (maxSpread - u1) * connectionInfluence;
            const angle2 = angleBetweenCenters - (u1 + (maxSpread - u1) * connectionInfluence);
            const angle3 = angleBetweenCenters + Math.PI - u2 - (Math.PI - u2 - maxSpread) * connectionInfluence;
            const angle4 = angleBetweenCenters - (Math.PI - u2 - (Math.PI - u2 - maxSpread) * connectionInfluence);
            
            // Longitud de handles para curvas Bezier
            const h = (4 * Math.tan(centerAngle / 4) / 3) * r;
            const hpi = Math.PI / 2;
            
            // Puntos de ancla (f√≥rmula original)
            const p0_anchor = [c1.x + r1 * Math.cos(ot1 + t1), c1.y + r1 * Math.sin(ot1 + t1)];
            const p1_anchor = [c2.x + r2 * Math.cos(ot2 - t2), c2.y + r2 * Math.sin(ot2 - t2)];
            const p2_anchor = [c2.x + r2 * Math.cos(ot2 + t2), c2.y + r2 * Math.sin(ot2 + t2)];
            const p3_anchor = [c1.x + r1 * Math.cos(ot1 - t1), c1.y + r1 * Math.sin(ot1 - t1)];
            
            // Puntos de control (handles)
            const p0_right = [p0_anchor[0] + h * Math.cos(ot1 + t1 - hpi), p0_anchor[1] + h * Math.sin(ot1 + t1 - hpi)];
            const p1_left = [p1_anchor[0] + h * Math.cos(ot2 - t2 + hpi), p1_anchor[1] + h * Math.sin(ot2 - t2 + hpi)];
            const p2_right = [p2_anchor[0] + h * Math.cos(ot2 + t2 - hpi), p2_anchor[1] + h * Math.sin(ot2 + t2 - hpi)];
            const p3_left = [p3_anchor[0] + h * Math.cos(ot1 - t1 + hpi), p3_anchor[1] + h * Math.sin(ot1 - t1 + hpi)];
            
            console.log('Puntos calculados:', { p0_anchor, p1_anchor, p2_anchor, p3_anchor });
            
            // Renderizar la metaball con SVG
            console.log('üé® Renderizando metaball con SVG');
            
            // Crear path SVG para la metaball
            const metaballPath = document.createElementNS(svgNS, 'path');
            
            // Construir el path data
            const pathData = [
                `M ${p0_anchor[0].toFixed(2)} ${p0_anchor[1].toFixed(2)}`, // Move to p0
                `C ${p0_right[0].toFixed(2)} ${p0_right[1].toFixed(2)}`,  // Control desde p0
                `${p1_left[0].toFixed(2)} ${p1_left[1].toFixed(2)}`,      // Control hacia p1
                `${p1_anchor[0].toFixed(2)} ${p1_anchor[1].toFixed(2)}`,   // Destino p1
                `L ${p2_anchor[0].toFixed(2)} ${p2_anchor[1].toFixed(2)}`, // L√≠nea a p2
                `C ${p2_right[0].toFixed(2)} ${p2_right[1].toFixed(2)}`,  // Control desde p2
                `${p3_left[0].toFixed(2)} ${p3_left[1].toFixed(2)}`,      // Control hacia p3
                `${p3_anchor[0].toFixed(2)} ${p3_anchor[1].toFixed(2)}`,   // Destino p3
                'Z' // Cerrar path
            ].join(' ');
            
            metaballPath.setAttribute('d', pathData);
            metaballPath.setAttribute('fill', '#ffffff');
            metaballPath.setAttribute('opacity', '1.0');
            // metaballPath.setAttribute('filter', 'url(#glow)');
            
            // Agregar borde si la conexi√≥n est√° seleccionada
            if (connection && connection.isSelected) {
                metaballPath.setAttribute('stroke', '#00ff00');
                metaballPath.setAttribute('stroke-width', '1');
            }
            
            // A√±adir al SVG
            svg.appendChild(metaballPath);
            
            console.log('‚úÖ Metaball renderizada con f√≥rmula original');
        }
        
        // Inicializar grid de c√≠rculos (SVG)
        function init() {
    // Estado base de modo conexiones: Global
    connectionFactorMode = 'global';
    selectedConnections = [];
    connections.forEach(conn => conn.isSelected = false);
    document.getElementById('globalMode').classList.add('active');
    document.getElementById('individualMode').classList.remove('active');
            const svgWidth = window.innerWidth;
            const svgHeight = window.innerHeight;
            svg.setAttribute('width', svgWidth);
            svg.setAttribute('height', svgHeight);
            
            circles = [];
            connections = [];
console.log('Conexiones tras init:', connections);
            selectedCircles = [];
            
            const padding = 200;
            const availableWidth = svgWidth - padding * 2;
            const availableHeight = svgHeight - padding * 2;
            
            spacing = Math.min(availableWidth / (gridCountX - 1), availableHeight / (gridCountY - 1));
            // Forzar radio m√°ximo permitido seg√∫n spacing
            const maxRadius = Math.floor(spacing / 2);
            const ballSizeSlider = document.getElementById('ballSizeSlider');
            ballSizeSlider.max = maxRadius;
            // Si el radio actual es mayor al nuevo m√°ximo, ajusta
            if (baseRadius > maxRadius) baseRadius = maxRadius;
            // Actualiza display
            
if (ballSizeSlider) ballSizeSlider.value = baseRadius;
if (ballSizeInput) ballSizeInput.value = baseRadius;
            
            const startX = (svgWidth - (gridCountX - 1) * spacing) / 2;
            const startY = (svgHeight - (gridCountY - 1) * spacing) / 2;
            
            for (let i = 0; i < gridCountX; i++) {
                for (let j = 0; j < gridCountY; j++) {
                    const x = startX + i * spacing;
                    const y = startY + j * spacing;
                    circles.push(new Circle(x, y, baseRadius, i, j));
                }
            }
            
            updateDisplays();
        }
        
        // Funci√≥n principal de dibujo (SVG)
        function draw() {
            // Limpiar SVG (incluye l√≠neas de ghost para no dejar rastro)
            const elementsToRemove = svg.querySelectorAll('circle, path, text, line');
            elementsToRemove.forEach(el => el.remove());
            
            // Dibujar conexiones manuales primero (para que aparezcan detr√°s)
            connections.forEach((conn, index) => {
                if (conn.from.radius > 0 && conn.to.radius > 0) {
                    const res = connectCirclesKuckir(conn.from, conn.to, conn);
                    if (!res) return;
                    const { pathData, overlayWidth } = res;
                    const metaballPath = document.createElementNS(svgNS, 'path');
                    metaballPath.setAttribute('d', pathData);
                    metaballPath.setAttribute('fill', '#ffffff');
                    metaballPath.setAttribute('opacity', '1.0');
                    // No interceptar eventos; overlay se encarga del click
                    metaballPath.setAttribute('pointer-events', 'none');
                    if (conn && conn.isSelected) {
                        metaballPath.setAttribute('stroke', '#00ff00');
                        metaballPath.setAttribute('stroke-width', '1');
                    }
                    svg.appendChild(metaballPath);

                    // Overlay invisible para hit-testing preciso
                    const overlay = document.createElementNS(svgNS, 'path');
                    overlay.setAttribute('d', pathData);
                    overlay.setAttribute('fill', 'none');
                    overlay.setAttribute('stroke', 'transparent');
                    overlay.setAttribute('stroke-width', String(overlayWidth));
                    const overlayActive = (editMode === 'connect') || (connectionFactorMode === 'individual');
                    overlay.setAttribute('pointer-events', overlayActive ? 'stroke' : 'none');
                    overlay.setAttribute('stroke-linecap', 'round');
                    overlay.setAttribute('stroke-linejoin', 'round');
                    overlay.setAttribute('class', 'conn-overlay');
                    overlay.style.cursor = overlayActive ? 'pointer' : 'default';
                    overlay.dataset.connIndex = String(index);
                    svg.appendChild(overlay);
                }
            });

            
            // Dibujar c√≠rculos encima de las conexiones
            circles.forEach(circle => {
                if (circle.radius > 0) {
                    circle.draw();
                }
            });
            
            // Mostrar c√≠rculo que estamos conectando
            if (editMode === 'connect' && connectingFrom) {
                const connectingIndicator = document.createElementNS(svgNS, 'circle');
                connectingIndicator.setAttribute('cx', connectingFrom.x);
                connectingIndicator.setAttribute('cy', connectingFrom.y);
                connectingIndicator.setAttribute('r', Math.max(connectingFrom.radius + 5, 20));
                connectingIndicator.setAttribute('fill', 'none');
                connectingIndicator.setAttribute('stroke', '#ffff00');
                connectingIndicator.setAttribute('stroke-width', '1');
                connectingIndicator.setAttribute('stroke-dasharray', '5,5');
                connectingIndicator.setAttribute('opacity', '0.8');
                svg.appendChild(connectingIndicator);
            }
            
            // Preview de conexi√≥n durante drag-to-connect
            if (draggingFrom && isDraggingConnect) {
                const hovered = circles.find(c => c.isHovered) || null;
                const tx = (hovered && hovered !== draggingFrom) ? hovered.x : mouseXGlobal;
                const ty = (hovered && hovered !== draggingFrom) ? hovered.y : mouseYGlobal;
                const ghost = document.createElementNS(svgNS, 'line');
                ghost.setAttribute('x1', String(draggingFrom.x));
                ghost.setAttribute('y1', String(draggingFrom.y));
                ghost.setAttribute('x2', String(tx));
                ghost.setAttribute('y2', String(ty));
                ghost.setAttribute('stroke', '#0ea5e9');
                ghost.setAttribute('stroke-width', '2');
                ghost.setAttribute('stroke-dasharray', '6 6');
                ghost.setAttribute('opacity', '0.9');
                ghost.setAttribute('pointer-events', 'none');
                svg.appendChild(ghost);
            }
        }
        
        // Event listeners del SVG
        svg.addEventListener('mousemove', (event) => {
            const rect = svg.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            
            // Reset hover states
            circles.forEach(circle => circle.isHovered = false);
            
            // Find hovered circle
            const hoveredCircle = circles.find(circle => circle.contains(mouseX, mouseY));
            if (hoveredCircle) {
                hoveredCircle.isHovered = true;
            }

            // Actualizar posici√≥n global del mouse y gestionar drag-to-connect (solo en modo Connect)
            mouseXGlobal = mouseX;
            mouseYGlobal = mouseY;
            if (draggingFrom && editMode === 'connect') {
                const dist = Math.hypot(mouseX - dragStartX, mouseY - dragStartY);
                if (!isDraggingConnect && dist >= DRAG_THRESHOLD_PX) {
                    isDraggingConnect = true;
                    const modeEl = document.getElementById('modeStatus');
                    if (modeEl) modeEl.textContent = 'quick_connect_mode';
                }
            }
            
            draw();
        });
        
        svg.addEventListener('click', (event) => {
            if (suppressNextClick) { suppressNextClick = false; return; }
            const rect = svg.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            
            const clickedCircle = circles.find(circle => circle.contains(mouseX, mouseY));
            let clickedConnection = null;
            const t = event.target;
            if (!clickedCircle && t && t.dataset && typeof t.dataset.connIndex !== 'undefined') {
                const idx = Number(t.dataset.connIndex);
                if (!Number.isNaN(idx) && connections[idx]) {
                    clickedConnection = connections[idx];
                }
            }
            if (!clickedCircle && !clickedConnection) {
                clickedConnection = getClickedConnection(mouseX, mouseY);
            }
            
            // Manejar selecci√≥n de conexiones en modo individual
            if (connectionFactorMode === 'individual' && clickedConnection && !clickedCircle) {
                if (isMac ? event.metaKey : event.ctrlKey) {
                    // Multi-selecci√≥n de conexiones
                    clickedConnection.isSelected = !clickedConnection.isSelected;
                    if (clickedConnection.isSelected) {
                        if (!selectedConnections.includes(clickedConnection)) {
                            selectedConnections.push(clickedConnection);
                        }
                    } else {
                        selectedConnections = selectedConnections.filter(c => c !== clickedConnection);
                    }
                } else {
                    // Selecci√≥n simple: limpiar todo y seleccionar solo esta conexi√≥n
                    selectedConnections.forEach(c => c.isSelected = false);
                    selectedConnections = [clickedConnection];
                    clickedConnection.isSelected = true;
                }
                
                // Actualizar slider al valor de la conexi√≥n seleccionada
                if (selectedConnections.length === 1) {
                    const newValue = selectedConnections[0].connectionFactor;
                    document.getElementById('connectionSlider').value = newValue;
                    const cv = document.getElementById('connectionValue');
                    if (cv) cv.textContent = newValue.toFixed(1);
                }
                
                // Actualizar UI contextual para mostrar/ocultar slider
                if (typeof updateUIContext === 'function') updateUIContext();
                draw();
                return;
            }
            
            if (!clickedCircle) return;
            
            if (editMode === 'select') {
                // Modo selecci√≥n
                if (isMac ? event.metaKey : event.ctrlKey) {
                    // Multi-selecci√≥n: toggle el estado del c√≠rculo clickeado
                    clickedCircle.isSelected = !clickedCircle.isSelected;
                    if (clickedCircle.isSelected) {
                        // A√±adir a la selecci√≥n si no est√° ya
                        if (!selectedCircles.includes(clickedCircle)) {
                            selectedCircles.push(clickedCircle);
                        }
                    } else {
                        // Remover de la selecci√≥n
                        selectedCircles = selectedCircles.filter(c => c !== clickedCircle);
                    }
                } else {
                    // Selecci√≥n simple: limpiar y seleccionar solo el clickeado
                    selectedCircles.forEach(c => c.isSelected = false);
                    selectedCircles = [clickedCircle];
                    clickedCircle.isSelected = true;
                }
                
                updateSelectedInfo();
                draw();
                
            } else if (editMode === 'connect') {
                // Modo conexi√≥n: click en dos bolas consecutivas conecta (ya implementado aparte)
                if (!connectingFrom) {
                    connectingFrom = clickedCircle;
                } else if (connectingFrom !== clickedCircle) {
                    const existingConnection = connections.find(conn => 
                        (conn.from === connectingFrom && conn.to === clickedCircle) ||
                        (conn.from === clickedCircle && conn.to === connectingFrom)
                    );
                    if (!existingConnection) {
                        connections.push({ from: connectingFrom, to: clickedCircle, connectionFactor, isSelected: false });
                        updateDisplays();
                    }
                    connectingFrom = null;
                } else {
                    connectingFrom = null;
                }
                draw();
            }
        });
        
        svg.addEventListener('mousedown', (event) => {
            if (event.button !== 0 || editMode !== 'connect') return; // S√≥lo bot√≥n izquierdo y en modo Connect
            const rect = svg.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            const clickedCircle = circles.find(circle => circle.contains(mouseX, mouseY));
            if (!clickedCircle) return;
            draggingFrom = clickedCircle;
            dragStartX = mouseXGlobal = mouseX;
            dragStartY = mouseYGlobal = mouseY;
            isDraggingConnect = false;
        });
        
        document.addEventListener('mouseup', (event) => {
            if (!draggingFrom) return;
            const wasDragging = isDraggingConnect;
            const rect = svg.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            const targetCircle = circles.find(circle => circle.contains(mouseX, mouseY));

            if (editMode === 'connect' && wasDragging && targetCircle && targetCircle !== draggingFrom) {
                const existing = connections.find(conn =>
                    (conn.from === draggingFrom && conn.to === targetCircle) ||
                    (conn.from === targetCircle && conn.to === draggingFrom)
                );
                if (!existing) {
                    connections.push({
                        from: draggingFrom,
                        to: targetCircle,
                        connectionFactor: connectionFactor,
                        isSelected: false
                    });
                    updateDisplays();
                }
                suppressNextClick = true; // Evita que el click suelto dispare selecci√≥n extra
            }

            draggingFrom = null;
            isDraggingConnect = false;
            const modeEl = document.getElementById('modeStatus');
            if (modeEl) modeEl.textContent = (editMode === 'connect') ? 'connect_balls' : 'select_balls';
            draw();
        });
        
        // Funciones de actualizaci√≥n de displays
        function updateSelectedInfo() {
            const ballSizeSlider = document.getElementById('ballSizeSlider');
            
            if (selectedCircles.length === 0) {
                ballSizeSlider.disabled = true;
                ballSizeInput.disabled = true;
                ballSizeSlider.value = baseRadius;
                ballSizeInput.value = baseRadius;
            } else if (selectedCircles.length === 1) {
                ballSizeSlider.disabled = false;
                ballSizeInput.disabled = false;
                ballSizeSlider.value = selectedCircles[0].radius;
                ballSizeInput.value = selectedCircles[0].radius;
            } else {
                // M√∫ltiples seleccionadas
                const avgSize = Math.round(selectedCircles.reduce((sum, c) => sum + c.radius, 0) / selectedCircles.length);
                ballSizeSlider.value = avgSize;
                ballSizeInput.value = avgSize;
                ballSizeSlider.disabled = false;
                ballSizeInput.disabled = false;
            }
            
            updateBallSizeDisplay();
        }
        
        function updateDisplays() {
            // Sincronizar controles de connection factor seg√∫n contexto
            const connectionSliderEl = document.getElementById('connectionSlider');
            const connectionValueEl = document.getElementById('connectionValue');
            let cfToShow = connectionFactor;
            if (connectionFactorMode === 'individual' && selectedConnections.length > 0) {
                cfToShow = selectedConnections[0].connectionFactor;
            }
            if (connectionSliderEl) connectionSliderEl.value = cfToShow;
            if (connectionInput) connectionInput.value = cfToShow;
            if (connectionValueEl) connectionValueEl.textContent = Number(cfToShow).toFixed(1);
            document.getElementById('gridSizeValue').textContent = `${gridCountX}√ó${gridCountY} = ${gridCountX * gridCountY}`;
            // Sync bridge width controls
            if (bridgeWidthSlider) bridgeWidthSlider.value = bridgeWidth;
            if (bridgeWidthInput) bridgeWidthInput.value = bridgeWidth.toFixed(1);
            
            // Actualizar contador de conexiones con informaci√≥n de selecci√≥n
            let connectionsText = `${connections.length} connections`;
            if (connectionFactorMode === 'individual' && selectedConnections.length > 0) {
                connectionsText += ` (${selectedConnections.length} selected)`;
            }
            document.getElementById('connectionsCount').textContent = connectionsText;
            
            updateSelectedInfo();
        }
        
        function updateBallSizeDisplay() {
    const value = ballSizeSlider.value;
    ballSizeInput.value = value;
}
        
        // Event Listeners para controles
        document.getElementById('selectMode').addEventListener('click', () => {
            editMode = 'select';
            connectingFrom = null;
            const btnConnect = document.getElementById('connectMode');
            if (btnConnect) btnConnect.classList.remove('active');
            const btnSelect = document.getElementById('selectMode');
            if (btnSelect) btnSelect.classList.add('active');
            const modeEl = document.getElementById('modeStatus');
            if (modeEl) modeEl.textContent = 'select_balls';

            draw();
        });
        
        document.getElementById('connectMode').addEventListener('click', () => {
            editMode = 'connect';
            connectingFrom = null;
            const btnConnect = document.getElementById('connectMode');
            if (btnConnect) btnConnect.classList.add('active');
            const btnSelect = document.getElementById('selectMode');
            if (btnSelect) btnSelect.classList.remove('active');
            const modeEl = document.getElementById('modeStatus');
            if (modeEl) modeEl.textContent = 'connect_balls';
            draw();
        });
        
        // Event listeners para Connection Factor Mode Toggle
        document.getElementById('globalMode').addEventListener('click', () => {
            connectionFactorMode = 'global';
            selectedConnections = []; // Limpiar selecciones
            connections.forEach(conn => conn.isSelected = false);
            const btnGlobal = document.getElementById('globalMode');
            if (btnGlobal) btnGlobal.classList.add('active');
            const btnInd = document.getElementById('individualMode');
            if (btnInd) btnInd.classList.remove('active');
            const cmEl = document.getElementById('connectionModeStatus');
            if (cmEl) cmEl.textContent = 'affects_all_connections';
            draw();
        });
        
        document.getElementById('individualMode').addEventListener('click', () => {
            connectionFactorMode = 'individual';
            const btnGlobal = document.getElementById('globalMode');
            if (btnGlobal) btnGlobal.classList.remove('active');
            const btnInd = document.getElementById('individualMode');
            if (btnInd) btnInd.classList.add('active');
            const cmEl = document.getElementById('connectionModeStatus');
            if (cmEl) cmEl.textContent = 'click_connections_to_select';
            draw();
        });
        
        // --- Referencias globales a controles ---
const ballSizeSlider = document.getElementById('ballSizeSlider');
const ballSizeInput = document.getElementById('ballSizeInput');
const connectionSlider = document.getElementById('connectionSlider');
const connectionInput = document.getElementById('connectionInput');
const bridgeWidthSlider = document.getElementById('bridgeWidthSlider');
const bridgeWidthInput = document.getElementById('bridgeWidthInput');

// Sincronizaci√≥n robusta: solo enteros
ballSizeSlider.addEventListener('input', (event) => {
    let newSize = Math.round(Number(event.target.value));
    ballSizeInput.value = newSize;
    selectedCircles.forEach(circle => {
        circle.radius = newSize;
    });
    updateBallSizeDisplay();
    draw();
});

// Bridge width controls
bridgeWidthSlider.addEventListener('input', (event) => {
    const v = parseFloat(event.target.value);
    bridgeWidth = v;
    bridgeWidthInput.value = v.toFixed(1);
    draw();
});
bridgeWidthInput.addEventListener('input', (event) => {
    let v = parseFloat(event.target.value);
    const min = parseFloat(bridgeWidthSlider.min);
    const max = parseFloat(bridgeWidthSlider.max);
    if (isNaN(v)) v = min;
    v = Math.max(min, Math.min(max, v));
    bridgeWidth = v;
    bridgeWidthSlider.value = v;
    bridgeWidthInput.value = v.toFixed(1);
    draw();
});
ballSizeInput.addEventListener('input', (event) => {
    let newSize = Math.round(Number(event.target.value));
    const min = parseInt(ballSizeSlider.min);
    const max = parseInt(ballSizeSlider.max);
    if (isNaN(newSize)) newSize = min;
    newSize = Math.max(min, Math.min(max, newSize));
    ballSizeInput.value = newSize;
    ballSizeSlider.value = newSize;
    selectedCircles.forEach(circle => {
        circle.radius = newSize;
    });
    updateBallSizeDisplay();
    draw();
});
        
        

// Permitir decimales, sincronizaci√≥n precisa
connectionSlider.addEventListener('input', (event) => {
    const newFactor = parseFloat(event.target.value);
    connectionInput.value = newFactor;
    if (connectionFactorMode === 'global') {
        connectionFactor = newFactor;
        connections.forEach(conn => {
            conn.connectionFactor = newFactor;
        });
    } else {
        if (selectedConnections.length > 0) {
            selectedConnections.forEach(conn => {
                conn.connectionFactor = newFactor;
            });
        } else {
            connectionFactor = newFactor;
        }
    }
    updateDisplays();
    draw();
});

connectionInput.addEventListener('input', (event) => {
    let newFactor = parseFloat(event.target.value);
    const min = parseFloat(connectionSlider.min);
    const max = parseFloat(connectionSlider.max);
    if (isNaN(newFactor)) newFactor = min;
    newFactor = Math.max(min, Math.min(max, newFactor));
    connectionInput.value = newFactor;
    connectionSlider.value = newFactor;
    if (connectionFactorMode === 'global') {
        connectionFactor = newFactor;
        connections.forEach(conn => {
            conn.connectionFactor = newFactor;
        });
    } else {
        if (selectedConnections.length > 0) {
            selectedConnections.forEach(conn => {
                conn.connectionFactor = newFactor;
            });
        } else {
            connectionFactor = newFactor;
        }
    }
    updateDisplays();
    draw();
});
        
        document.getElementById('clearConnections').addEventListener('click', () => {
            connections = [];
            updateDisplays();
            draw();
        });
        
        document.getElementById('resetAll').addEventListener('click', () => {
            circles.forEach(circle => {
                circle.radius = baseRadius;
                circle.isSelected = false;
            });
            selectedCircles = [];
            connections = [];
            connectingFrom = null;
            updateDisplays();
            draw();
        });
        
        // Event listeners para grid size
        ['gridRowsInput', 'gridColsInput'].forEach(id => {
            document.getElementById(id).addEventListener('input', (event) => {
                const newValue = parseInt(event.target.value);
                if (newValue >= 3 && newValue <= 12) {
                    if (id === 'gridRowsInput') gridCountY = newValue;
                    else gridCountX = newValue;
                    init();
                }
            });
        });
        
        // === CONTROLES AVANZADOS DE MOUSE ===
        let spacePressed = false;
        let ctrlPressed = false;
        const isMac = !!(navigator && navigator.platform && navigator.platform.toUpperCase().includes('MAC'));
        
        // Detectar teclas
        document.addEventListener('keydown', (event) => {
            if (event.code === 'Space') {
                spacePressed = true;
                event.preventDefault();
            }
            if (event.ctrlKey || event.metaKey) {
                ctrlPressed = true;
                
                // Ctrl+A / Cmd+A = Select All
                if (event.code === 'KeyA' && editMode === 'select') {
                    event.preventDefault();
                    selectedCircles.forEach(c => c.isSelected = false);
                    selectedCircles = [...circles];
                    circles.forEach(circle => circle.isSelected = true);
                    updateSelectedInfo();
                    draw();
                }
            }
            
            // Escape = Deselect All
            if (event.code === 'Escape') {
                selectedCircles.forEach(c => c.isSelected = false);
                selectedCircles = [];
                connectingFrom = null;
                updateSelectedInfo();
                draw();
            }
        });
        
        document.addEventListener('keyup', (event) => {
            if (event.code === 'Space') {
                spacePressed = false;
                event.preventDefault();
            }
            if (!event.ctrlKey && !event.metaKey) {
                ctrlPressed = false;
            }
        });
        
        // Scroll para control de valores
        svg.addEventListener('wheel', (event) => {
            event.preventDefault();
            
            const rect = svg.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            const hoveredCircle = circles.find(circle => circle.contains(mouseX, mouseY));
            const delta = -event.deltaY / 100; // Normalizar scroll

            if (editMode === 'connect') {
                // Ajuste de Connection Factor por rueda (independiente de hoveredCircle)
                const slider = document.getElementById('connectionSlider');
                const min = slider ? parseFloat(slider.min) : 0.1;
                const max = slider ? parseFloat(slider.max) : 8.0;
                const step = 0.1;

                if (connectionFactorMode === 'individual') {
                    // 1) Si el target es un overlay de conexi√≥n, ajustar esa conexi√≥n
                    let adjustedAny = false;
                    const t = event.target;
                    if (t && t.classList && t.classList.contains('conn-overlay') && typeof t.dataset.connIndex !== 'undefined') {
                        const idx = Number(t.dataset.connIndex);
                        if (!Number.isNaN(idx) && connections[idx]) {
                            const c = connections[idx];
                            const nv = Math.max(min, Math.min(max, Number((c.connectionFactor + delta * step).toFixed(1))));
                            c.connectionFactor = nv;
                            adjustedAny = true;
                        }
                    }
                    // 2) Si no hay overlay, ajustar conexiones seleccionadas (si existen)
                    if (!adjustedAny && selectedConnections.length > 0) {
                        selectedConnections.forEach(c => {
                            const nv = Math.max(min, Math.min(max, Number((c.connectionFactor + delta * step).toFixed(1))));
                            c.connectionFactor = nv;
                        });
                        adjustedAny = true;
                    }
                    // 3) Fallback: ajustar global si no hay objetivo individual
                    if (!adjustedAny) {
                        const nf = Math.max(min, Math.min(max, Number((connectionFactor + delta * step).toFixed(1))));
                        connectionFactor = nf;
                    }
                } else {
                    // Global: actualizar factor global y propagar a todas las conexiones
                    const nf = Math.max(min, Math.min(max, Number((connectionFactor + delta * step).toFixed(1))));
                    connectionFactor = nf;
                    connections.forEach(c => { c.connectionFactor = connectionFactor; });
                }

                // Sincronizar UI
                if (slider) slider.value = connectionFactor;
                const cv = document.getElementById('connectionValue');
                if (cv) cv.textContent = (connectionFactor).toFixed(1);
                updateDisplays();
                draw();
                return;
            }

            // En modo select: scroll ajusta tama√±o de la bola si procede
            if (hoveredCircle && (spacePressed || hoveredCircle.isSelected)) {
                if (selectedCircles.length > 1 && hoveredCircle.isSelected) {
                    // Cambiar el tama√±o de TODAS las seleccionadas
                    const deltaSize = delta * 3;
                    selectedCircles.forEach(circle => {
                        const newRadius = Math.max(0, Math.min(100, circle.radius + deltaSize));
                        circle.radius = newRadius;
                    });
                    // Actualizar slider con el valor de la bola sobre la que hicimos hover
                    document.getElementById('ballSizeSlider').value = hoveredCircle.radius;
                    updateBallSizeDisplay();
                } else {
                    // Comportamiento normal para una sola bola
                    const newRadius = Math.max(0, Math.min(100, hoveredCircle.radius + delta * 3));
                    hoveredCircle.radius = newRadius;
                    if (hoveredCircle.isSelected) {
                        document.getElementById('ballSizeSlider').value = newRadius;
                        updateBallSizeDisplay();
                    }
                }
                draw();
            }
        });
        
        // Click mejorado con teclas modificadoras
        svg.addEventListener('click', (event) => {
            if (suppressNextClick) { suppressNextClick = false; return; }
            const rect = svg.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            const clickedCircle = circles.find(circle => circle.contains(mouseX, mouseY));
            
            if (!clickedCircle) return;
            
            // Space + Click = Selecci√≥n r√°pida (sin cambiar modo)
            if (spacePressed) {
                clickedCircle.isSelected = !clickedCircle.isSelected;
                if (clickedCircle.isSelected) {
                    if (!selectedCircles.includes(clickedCircle)) {
                        selectedCircles.push(clickedCircle);
                    }
                } else {
                    selectedCircles = selectedCircles.filter(c => c !== clickedCircle);
                }
                updateSelectedInfo();
                draw();
                // Evitar que el handler de burbuja revierta el toggle
                event.stopPropagation();
                event.preventDefault();
                return;
            }
            
            // El resto del c√≥digo de click normal continuar√° despu√©s
        }, true); // useCapture = true para capturar antes que el evento normal
        
        // Funci√≥n para descargar SVG
        async function downloadSVG() {
            try {
                // Crear una copia del SVG para descarga
                const svgClone = svg.cloneNode(true);
                // Eliminar overlays invisibles de hit-testing
                const overlays = svgClone.querySelectorAll('.conn-overlay');
                overlays.forEach(el => el.parentNode && el.parentNode.removeChild(el));
                
                // Asegurar namespaces y atributos correctos
                svgClone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
                svgClone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
                svgClone.setAttribute('version', '1.1');
                
                // Serializar el SVG
                const svgData = new XMLSerializer().serializeToString(svgClone);
                const svgWithXML = '<?xml version="1.0" encoding="UTF-8"?>\n' + svgData;
                
                // Generar nombre de archivo
                const timestamp = new Date().toISOString().slice(0, 16).replace(/[:-]/g, '');
                const filename = `metaballs-svg-editor-${gridCountX}x${gridCountY}-${connections.length}conn-${timestamp}.svg`;
                
                // Descarga usando File System Access API si est√° disponible
                try {
                    if ('showSaveFilePicker' in window) {
                        const fileHandle = await window.showSaveFilePicker({
                            suggestedName: filename,
                            types: [{
                                description: 'SVG files',
                                accept: { 'image/svg+xml': ['.svg'] }
                            }]
                        });
                        const writable = await fileHandle.createWritable();
                        await writable.write(svgWithXML);
                        await writable.close();
                        console.log('‚úÖ SVG descargado via File System API:', filename);
                    } else {
                        // Descarga tradicional
                        const blob = new Blob([svgWithXML], { type: 'image/svg+xml;charset=utf-8' });
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        link.download = filename;
                        link.style.display = 'none';
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(url);
                        console.log('‚úÖ SVG descargado via m√©todo tradicional:', filename);
                    }
                } catch (downloadError) {
                    // Fallback: abrir en nueva ventana
                    const dataUrl = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgWithXML);
                    window.open(dataUrl, '_blank');
                    console.log('‚ö†Ô∏è SVG abierto en nueva ventana como fallback');
                }
                
            } catch (error) {
                console.error('‚ùå Error generando SVG:', error);
                alert('Error generando SVG. Revisa la consola para m√°s detalles.');
            }
        }
        
        // Event listener para descarga SVG
        document.getElementById('downloadSVG').addEventListener('click', downloadSVG);
        
        // Resize handler
        window.addEventListener('resize', () => {
            init();
        });
        
        // Inicializar
        init();
        draw();

        // --- Implementaci√≥n metaball Ivan Kuckir ---
 function connectCirclesKuckir(c1, c2, connection) {
    // Implementaci√≥n basada en Varun Vachhar: https://varun.ca/metaballs/
    const r1 = Math.max(0, c1.radius);
    const r2 = Math.max(0, c2.radius);
    if (r1 === 0 || r2 === 0) return;
    const dx = c2.x - c1.x;
    const dy = c2.y - c1.y;
    const d = Math.hypot(dx, dy);
    if (d <= 1e-6) return; // centros coincidentes
    if (d <= Math.abs(r1 - r2)) return; // una dentro de otra

    const usedFactor = (connection?.connectionFactor ?? connectionFactor);
    // Normalizamos factor [0,8] -> v ‚àà [0,1]
    const v = Math.max(0, Math.min(1, usedFactor / 8.0));

    // C√°lculos angulares
    const angleBetweenCenters = Math.atan2(dy, dx);
    const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
    const maxSpread = Math.acos(clamp((r1 - r2) / d, -1, 1));
    const u1 = Math.acos(clamp((r1*r1 + d*d - r2*r2) / (2 * r1 * d), -1, 1));
    const u2 = Math.acos(clamp((r2*r2 + d*d - r1*r1) / (2 * r2 * d), -1, 1));
    if (!Number.isFinite(u1) || !Number.isFinite(u2)) return;

    const angle1 = angleBetweenCenters + u1 + (maxSpread - u1) * v;
    const angle2 = angleBetweenCenters - (u1 + (maxSpread - u1) * v);
    const angle3 = angleBetweenCenters + Math.PI - u2 - (Math.PI - u2 - maxSpread) * v;
    const angle4 = angleBetweenCenters - (Math.PI - u2 - (Math.PI - u2 - maxSpread) * v);

    // Puntos
    const p1 = { x: c1.x + r1 * Math.cos(angle1), y: c1.y + r1 * Math.sin(angle1) };
    const p2 = { x: c1.x + r1 * Math.cos(angle2), y: c1.y + r1 * Math.sin(angle2) };
    const p3 = { x: c2.x + r2 * Math.cos(angle3), y: c2.y + r2 * Math.sin(angle3) };
    const p4 = { x: c2.x + r2 * Math.cos(angle4), y: c2.y + r2 * Math.sin(angle4) };

    // Handles B√©zier
    const handleSize = bridgeWidth;
    const totalRadius = r1 + r2;
    const dist13 = Math.hypot(p1.x - p3.x, p1.y - p3.y);
    let d2Base = Math.min(v * handleSize, dist13 / totalRadius);
    const overlapScale = Math.min(1, (d * 2) / (r1 + r2));
    let d2 = d2Base * overlapScale;
    if (!Number.isFinite(d2) || d2 < 0) d2 = 0;

    const HALF_PI = Math.PI / 2;
    const r1h = r1 * d2;
    const r2h = r2 * d2;
    const h1 = { x: p1.x + Math.cos(angle1 - HALF_PI) * r1h, y: p1.y + Math.sin(angle1 - HALF_PI) * r1h };
    const h2 = { x: p2.x + Math.cos(angle2 + HALF_PI) * r1h, y: p2.y + Math.sin(angle2 + HALF_PI) * r1h };
    const h3 = { x: p3.x + Math.cos(angle3 + HALF_PI) * r2h, y: p3.y + Math.sin(angle3 + HALF_PI) * r2h };
    const h4 = { x: p4.x + Math.cos(angle4 - HALF_PI) * r2h, y: p4.y + Math.sin(angle4 - HALF_PI) * r2h };

    // Elegir arco largo si no solapan (fuera), corto si solapan
    const escaped = d > (r1 + r2);
    const largeArcFlag2 = escaped ? 1 : 0;
    const largeArcFlag1 = escaped ? 1 : 0;
    const sweepFlag = 0;

    const pathData = [
        'M', p1.x, p1.y,
        'C', h1.x, h1.y, h3.x, h3.y, p3.x, p3.y,
        'A', r2, r2, 0, largeArcFlag2, sweepFlag, p4.x, p4.y,
        'C', h4.x, h4.y, h2.x, h2.y, p2.x, p2.y,
        'A', r1, r1, 0, largeArcFlag1, sweepFlag, p1.x, p1.y,
        'Z'
    ].join(' ');

    // Ancho sugerido para overlay de click: proporcional a radios
    const overlayWidth = Math.max(12, (r1 + r2) * 0.3);

    return { pathData, overlayWidth };
 }

// --- UI CONTEXTUAL Y MODAL DE AYUDA ---
        function updateUIContext() {
          // Paneles
          const ballControls = document.getElementById('ballControls');
          const connectionControls = document.getElementById('connectionControls');
          const connectionSliderBlock = document.getElementById('connectionSliderBlock');

          // Mostrar controles seg√∫n modo
          if (editMode === 'select') {
            ballControls.hidden = false;
            connectionControls.hidden = true;
          } else if (editMode === 'connect') {
            ballControls.hidden = true;
            connectionControls.hidden = false;
            // Mostrar slider solo si corresponde
            const showSlider =
              connectionFactorMode === 'global' ||
              (connectionFactorMode === 'individual' && selectedConnections.length > 0);
            connectionSliderBlock.hidden = !showSlider;
          }
        }

        // Modal de ayuda accesible
        const helpModal = document.getElementById('helpModal');
        const showHelpBtn = document.getElementById('showHelp');
        const closeHelpBtn = document.getElementById('closeHelp');

        showHelpBtn.addEventListener('click', () => {
          helpModal.style.display = 'flex';
          closeHelpBtn.focus();
        });
        closeHelpBtn.addEventListener('click', () => {
          helpModal.style.display = 'none';
          showHelpBtn.focus();
        });
        document.addEventListener('keydown', (e) => {
          if (helpModal.style.display === 'flex' && (e.key === 'Escape' || e.key === 'Esc')) {
            helpModal.style.display = 'none';
            showHelpBtn.focus();
          }
        });

        // Llama a updateUIContext en cada cambio de modo o selecci√≥n relevante
        document.getElementById('selectMode').addEventListener('click', () => {
          updateUIContext();
        });
        document.getElementById('connectMode').addEventListener('click', () => {
          updateUIContext();
        });
        document.getElementById('globalMode').addEventListener('click', () => {
          updateUIContext();
        });
        document.getElementById('individualMode').addEventListener('click', () => {
          updateUIContext();
        });
        // Llama tambi√©n tras cada selecci√≥n de conexi√≥n
        function updateSelectedConnectionsUI() {
          if (editMode === 'connect') updateUIContext();
        }
        // Hook: tras cada cambio de selectedConnections, llama a updateSelectedConnectionsUI()
        // (ya est√° en la l√≥gica de click de conexiones)

        // Llama al cargar
        updateUIContext();
    </script>
</body>
</html>
