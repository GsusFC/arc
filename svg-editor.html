<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metaballs - SVG Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'JetBrains Mono', monospace;
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            color: #ffffff;
        }
        
        .floating-controls {
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .floating-controls h3 {
            text-shadow: 1px 1px 3px rgba(0,0,0,0.9);
        }
        
        /* Estilos para sliders */
        .slider::-webkit-slider-thumb {
            appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 2px;
            background: #00ff00;
            cursor: pointer;
            border: 1px solid #ffffff;
            box-shadow: none;
        }
        
        .slider::-moz-range-thumb {
            height: 16px;
            width: 16px;
            border-radius: 2px;
            background: #00ff00;
            cursor: pointer;
            border: 1px solid #ffffff;
            box-shadow: none;
        }
        
        .slider {
            background: #333333 !important;
            border: 1px solid #ffffff;
        }
        
        /* Checkbox terminal style */
        .terminal-checkbox {
            appearance: none;
            width: 16px;
            height: 16px;
            border: 1px solid #ffffff;
            background: #000000;
            position: relative;
            cursor: pointer;
        }
        
        .terminal-checkbox:checked {
            background: #00ff00;
        }
        
        .terminal-checkbox:checked::after {
            content: '‚úì';
            position: absolute;
            top: -2px;
            left: 2px;
            color: #000000;
            font-size: 12px;
            font-weight: bold;
        }
        
        /* Botones */
        .btn {
            padding: 8px 12px;
            border: 1px solid #ffffff;
            background: #000000;
            color: #ffffff;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn:hover {
            background: #333333;
        }
        
        .btn.active {
            background: #00ff00;
            color: #000000;
        }
        
        .btn.danger {
            border-color: #ff0000;
            color: #ff0000;
        }
        
        .btn.danger:hover {
            background: #ff0000;
            color: #ffffff;
        }

        /* Navigation button styles */
        .nav-button {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 20;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #ffffff;
            padding: 8px 12px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: #ffffff;
            text-decoration: none;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .nav-button:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: #ff6b35;
            color: #ff6b35;
        }

        .version-indicator {
            position: absolute;
            top: -8px;
            right: -8px;
            background: #ff6b35;
            color: #000000;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
    </style>
</head>
<body class="bg-black text-white">
    <!-- Version Navigation -->
    <div class="fixed top-4 right-4 z-20 flex flex-col space-y-2">
        <div class="px-3 py-2 bg-black border border-white text-center">
            <div class="text-xs text-green-400 font-medium">üé® SVG EDITOR</div>
        </div>
        
        <!-- Quick Switch -->
        <div class="flex space-x-1">
            <button onclick="window.location.href='index.html'" 
                    class="px-2 py-1 bg-black border border-blue-400 text-blue-400 text-xs hover:bg-blue-400 hover:text-black transition-all" 
                    title="Canvas Dynamic">
                üé®
            </button>
            <button onclick="window.location.href='svg-version.html'" 
                    class="px-2 py-1 bg-black border border-purple-400 text-purple-400 text-xs hover:bg-purple-400 hover:text-black transition-all" 
                    title="SVG Static">
                üì•
            </button>
            <button onclick="window.location.href='svg-editor.html'" 
                    class="px-2 py-1 bg-black border border-green-400 text-green-400 text-xs hover:bg-green-400 hover:text-black transition-all" 
                    title="SVG Editor">
                üé®
            </button>
        </div>
    </div>
    
    <!-- Panel lateral flotante contextual -->
    <div class="fixed top-4 left-4 z-10 w-80 max-w-full flex flex-col gap-5 p-4 bg-black/80 rounded-xl border border-white shadow-xl" aria-label="Controles de edici√≥n metaballs">
        <!-- Modo de edici√≥n -->
        <section class="flex flex-col gap-2 border-b border-white/20 pb-3">
            <h2 class="text-xs font-bold uppercase tracking-wide text-green-400">Modo de edici√≥n</h2>
            <div class="flex gap-2">
                <button id="selectMode" class="btn w-1/2 uppercase font-semibold text-xs px-3 py-1 rounded border border-white transition focus:outline-none focus:ring-2 focus:ring-green-400" aria-label="Modo seleccionar">SELECT</button>
                <button id="connectMode" class="btn w-1/2 uppercase font-semibold text-xs px-3 py-1 rounded border border-white transition focus:outline-none focus:ring-2 focus:ring-green-400" aria-label="Modo conectar">CONNECT</button>
            </div>
            <span id="modeStatus" class="text-xs text-gray-400"></span>
        </section>

        <!-- Configuraci√≥n de bolas (solo en SELECT) -->
        <section id="ballControls" class="flex flex-col gap-2 border-b border-white/20 pb-3" hidden>
            <h2 class="text-xs font-bold uppercase tracking-wide text-blue-400">Bola seleccionada</h2>
            <div class="flex items-center gap-3">
                <span class="text-xs">Tama√±o</span>
                <input id="ballSizeSlider" type="range" min="0" max="100" step="1" class="flex-1" />
                <span id="ballSizeValue" class="text-xs text-green-400"></span>
            </div>
        </section>

        <!-- Configuraci√≥n de conexiones (solo en CONNECT) -->
        <section id="connectionControls" class="flex flex-col gap-2 border-b border-white/20 pb-3" hidden>
            <h2 class="text-xs font-bold uppercase tracking-wide text-pink-400">Conexiones</h2>
            <div class="flex gap-2 justify-between">
                <button id="globalMode" class="btn uppercase font-semibold text-xs px-3 py-1 rounded border border-white transition focus:outline-none focus:ring-2 focus:ring-pink-400">GLOBAL</button>
                <button id="individualMode" class="btn uppercase font-semibold text-xs px-3 py-1 rounded border border-white transition focus:outline-none focus:ring-2 focus:ring-pink-400">INDIVIDUAL</button>
            </div>
            <div id="connectionSliderBlock" class="flex items-center gap-3" hidden>
                <span class="text-xs">Factor</span>
                <input id="connectionSlider" type="range" min="0.5" max="5.0" step="0.1" class="flex-1" />
                <span id="connectionValue" class="text-xs text-green-400"></span>
            </div>
            <span id="connectionsCount" class="text-xs text-green-400"></span>
            <span id="connectionModeStatus" class="text-xs text-gray-400"></span>
            <button id="clearConnections" class="btn danger mt-2 uppercase font-semibold text-xs px-3 py-1 rounded border border-red-500 transition focus:outline-none focus:ring-2 focus:ring-red-400">CLEAR ALL</button>
        </section>

        <!-- Configuraci√≥n de grid (siempre visible) -->
        <section class="flex flex-col gap-2 border-b border-white/20 pb-3">
            <h2 class="text-xs font-bold uppercase tracking-wide text-yellow-400">Grid</h2>
            <div class="flex items-center gap-2">
                <label class="text-xs">Filas</label>
                <input id="gridRowsInput" type="number" min="3" max="12" value="5" class="w-12 text-xs text-center bg-black border border-white text-white rounded focus:outline-none focus:ring-2 focus:ring-yellow-400" aria-label="Filas del grid" />
                <span class="text-xs">√ó</span>
                <label class="text-xs">Cols</label>
                <input id="gridColsInput" type="number" min="3" max="12" value="5" class="w-12 text-xs text-center bg-black border border-white text-white rounded focus:outline-none focus:ring-2 focus:ring-yellow-400" aria-label="Columnas del grid" />
                <span id="gridSizeValue" class="text-xs text-green-400 ml-2"></span>
            </div>
        </section>

        <!-- Acciones -->
        <section class="flex flex-col gap-2">
            <div class="flex gap-2">
                <button id="downloadSVG" class="btn flex-1 border-green-400 text-green-400 uppercase font-semibold text-xs px-3 py-1 rounded border transition focus:outline-none focus:ring-2 focus:ring-green-400">üì• EXPORTAR SVG</button>
                <button id="resetAll" class="btn danger flex-1 uppercase font-semibold text-xs px-3 py-1 rounded border border-red-500 transition focus:outline-none focus:ring-2 focus:ring-red-400">RESET</button>
            </div>
            <button id="showHelp" class="btn text-xs mt-1 uppercase font-semibold px-3 py-1 rounded border border-white transition focus:outline-none focus:ring-2 focus:ring-yellow-400" aria-label="Mostrar ayuda y atajos">‚ùì AYUDA / ATAJOS</button>
        </section>
    </div>

    <!-- Modal de ayuda -->
    <div id="helpModal" class="fixed inset-0 bg-black/70 flex items-center justify-center z-50" style="display:none;" role="dialog" aria-modal="true" aria-label="Ayuda y atajos">
        <div class="bg-black border border-white rounded-lg p-6 max-w-md w-full shadow-2xl relative">
            <button id="closeHelp" class="absolute top-2 right-2 text-white text-lg" aria-label="Cerrar ayuda">&times;</button>
            <h2 class="text-lg font-bold mb-4 text-green-400">Atajos y controles avanzados</h2>
            <ul class="text-xs space-y-1 text-gray-200">
                <li><b>Click</b>: seleccionar bola/conexi√≥n</li>
                <li><b>Ctrl + Click</b>: multi-selecci√≥n</li>
                <li><b>Esc</b>: deseleccionar todo / cerrar modal</li>
                <li><b>Ctrl + A</b>: seleccionar todo</li>
                <li><b>Space + Click</b>: alternar selecci√≥n r√°pida</li>
                <li><b>Scroll</b>: cambiar tama√±o/factor seg√∫n contexto</li>
            </ul>
        </div>
    </div>

    <!-- SVG Container -->
    <svg id="svg" style="display: block; background-color: #000000; width: 100vw; height: 100vh;">
        <defs>
            <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
                <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                <feMerge>
                    <feMergeNode in="coloredBlur"/>
                    <feMergeNode in="SourceGraphic"/>
                </feMerge>
            </filter>
        </defs>
    </svg>
    
    <script>
        // Variables globales
        const svg = document.getElementById('svg');
        const svgNS = 'http://www.w3.org/2000/svg';
        
        let circles = [];
        let gridCountX = 5, gridCountY = 5;
        let baseRadius = 30;
        let connectionFactor = 4.0;
        let selectedCircles = [];
        let connections = [];
        let selectedConnections = []; // Conexiones seleccionadas para modo individual
        let connectionFactorMode = 'global'; // 'global' | 'individual'
        let editMode = 'select';
        let connectingFrom = null;
        let spacing = 120;
        
        class Circle {
            constructor(x, y, radius, gridI, gridJ) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.gridI = gridI;
                this.gridJ = gridJ;
                this.isSelected = false;
                this.isHovered = false;
            }
            
            contains(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance <= Math.max(this.radius, 15); // M√≠nimo 15px para selecci√≥n
            }
            
            draw() {
                // C√≠rculo principal
                const circle = document.createElementNS(svgNS, 'circle');
                circle.setAttribute('cx', this.x);
                circle.setAttribute('cy', this.y);
                circle.setAttribute('r', this.radius);
                circle.setAttribute('fill', '#ffffff');
                circle.setAttribute('opacity', '1.0');
                
                // Efecto glow opcional (comentado para mayor claridad)
                // circle.setAttribute('filter', 'url(#glow)');
                
                // A√±adir al SVG
                svg.appendChild(circle);
                
                // Borde si est√° seleccionado
                if (this.isSelected) {
                    const selectedBorder = document.createElementNS(svgNS, 'circle');
                    selectedBorder.setAttribute('cx', this.x);
                    selectedBorder.setAttribute('cy', this.y);
                    selectedBorder.setAttribute('r', this.radius + 3);
                    selectedBorder.setAttribute('fill', 'none');
                    selectedBorder.setAttribute('stroke', '#00ff00');
                    selectedBorder.setAttribute('stroke-width', '2');
                    selectedBorder.setAttribute('opacity', '1');
                    svg.appendChild(selectedBorder);
                }
                
                // Borde si est√° siendo hover
                if (this.isHovered && !this.isSelected) {
                    const hoverBorder = document.createElementNS(svgNS, 'circle');
                    hoverBorder.setAttribute('cx', this.x);
                    hoverBorder.setAttribute('cy', this.y);
                    hoverBorder.setAttribute('r', this.radius + 2);
                    hoverBorder.setAttribute('fill', 'none');
                    hoverBorder.setAttribute('stroke', '#ffffff');
                    hoverBorder.setAttribute('stroke-width', '1');
                    hoverBorder.setAttribute('opacity', '0.8');
                    svg.appendChild(hoverBorder);
                }
            }
        }
        
        // Funci√≥n para detectar click en conexiones (metaballs)
        function getClickedConnection(mouseX, mouseY) {
            for (let conn of connections) {
                if (conn.from.radius > 0 && conn.to.radius > 0) {
                    const r1 = conn.from.radius;
                    const r2 = conn.to.radius;
                    const d = Math.sqrt((conn.from.x - conn.to.x) ** 2 + (conn.from.y - conn.to.y) ** 2);
                    
                    const usedFactor = conn.connectionFactor;
                    const condition1 = d > (r1 + r2) * usedFactor;
                    const condition2 = d <= Math.abs(r1 - r2);
                    
                    // Solo revisar si la metaball existe
                    if (!condition1 && !condition2) {
                        // Aproximaci√≥n simple: verificar si el click est√° en la zona de la metaball
                        const midX = (conn.from.x + conn.to.x) / 2;
                        const midY = (conn.from.y + conn.to.y) / 2;
                        const avgRadius = (r1 + r2) / 2;
                        
                        const distanceToMid = Math.sqrt((mouseX - midX) ** 2 + (mouseY - midY) ** 2);
                        const threshold = avgRadius * 0.7;
                        
                        // Si est√° cerca del centro de la metaball, considerarlo un click (zona ampliada)
                        if (distanceToMid <= threshold * 1.5) { // Zona de click m√°s amplia
                            return conn;
                        }
                    }
                }
            }
            return null;
        }
        
        // Funci√≥n para crear conexi√≥n entre dos c√≠rculos
        function connectCircles(c1, c2, connection = null) {
            const r1 = Math.max(0, c1.radius);
            const r2 = Math.max(0, c2.radius);
            const d = Math.sqrt((c1.x - c2.x) ** 2 + (c1.y - c2.y) ** 2);
            
            // Usar connectionFactor individual o global seg√∫n el modo
            const usedConnectionFactor = connection ? connection.connectionFactor : connectionFactor;
            
            console.log('üîç Validando condiciones:');
            console.log('  r1:', r1, 'r2:', r2);
            console.log('  d:', d, 'threshold:', (r1 + r2) * usedConnectionFactor);
            console.log('  usedConnectionFactor:', usedConnectionFactor, 'mode:', connectionFactorMode);
            console.log('  Math.abs(r1 - r2):', Math.abs(r1 - r2));
            
            const condition1 = d > (r1 + r2) * usedConnectionFactor;
            const condition2 = d <= Math.abs(r1 - r2);
            const condition3 = r1 === 0;
            const condition4 = r2 === 0;
            
            console.log('  Condici√≥n 1 (d > threshold):', condition1);
            console.log('  Condici√≥n 2 (d <= |r1-r2|):', condition2);
            console.log('  Condici√≥n 3 (r1 === 0):', condition3);
            console.log('  Condici√≥n 4 (r2 === 0):', condition4);
            
            if (condition1 || condition2 || condition3 || condition4) {
                console.log('‚ùå SE SALE por condici√≥n:', {
                    distanciaMuyGrande: condition1,
                    distanciaMuyPeque√±a: condition2, 
                    radio1Cero: condition3,
                    radio2Cero: condition4
                });
                return;
            }
            
            console.log('‚úÖ Todas las condiciones pasaron, procediendo al renderizado');
            
            // F√≥rmula original de metaballs del script de Adobe Illustrator
            // Aplicar el connection_factor para mayor variabilidad en la forma
            const connectionInfluence = Math.pow(connectionFactor / 4.0, 1.5); // Normalizar y aplicar potencia
            const adjustedR1 = r1 * (0.7 + connectionInfluence * 0.6); // Entre 70% y 130%
            const adjustedR2 = r2 * (0.7 + connectionInfluence * 0.6);
            
            const centerAngle = Math.PI / 2; // 90 grados como en el script original
            const ot1 = Math.atan2(c2.y - c1.y, c2.x - c1.x);
            const ot2 = ot1 + Math.PI;
            
            // Ecuaci√≥n cuadr√°tica para calcular r (usando radios ajustados)
            const cos_ca = Math.cos(centerAngle);
            const a_coef = 2 - 2 * cos_ca;
            const b_coef = 2 * (1 - cos_ca) * (adjustedR1 + adjustedR2);
            const c_coef = adjustedR1 * adjustedR1 + adjustedR2 * adjustedR2 - d * d - 2 * adjustedR1 * adjustedR2 * cos_ca;
            
            console.log('Coeficientes ecuaci√≥n:', { a_coef, b_coef, c_coef });
            
            // Resolver ecuaci√≥n cuadr√°tica directamente
            let quad_a = a_coef;
            let quad_b = b_coef;
            let quad_c = c_coef;
            let r = null;
            
            if (quad_a === 0) {
                if (quad_b !== 0) {
                    const s = -quad_c / quad_b;
                    r = s > 0 ? s : null;
                }
            } else {
                quad_a *= 2;
                const discriminant = quad_b * quad_b - 2 * quad_a * quad_c;
                if (discriminant >= 0) {
                    const rd = Math.sqrt(discriminant);
                    if (discriminant > 0) {
                        const s1 = (-quad_b + rd) / quad_a;
                        const s2 = (-quad_b - rd) / quad_a;
                        if (s1 > 0 && s2 > 0) {
                            r = Math.min(s1, s2);
                        } else if (s1 > 0) {
                            r = s1;
                        } else if (s2 > 0) {
                            r = s2;
                        }
                    } else {
                        const s = -quad_b / quad_a;
                        r = s > 0 ? s : null;
                    }
                }
            }
            console.log('Radio calculado r:', r);
            if (r === null) {
                console.log('‚ùå No se puede resolver la ecuaci√≥n cuadr√°tica');
                return;
            }
            
            const radius_a = r1 + r;
            const radius_b = r2 + r;
            
            // C√°lculo de √°ngulos
            const cos_t1 = (radius_a * radius_a + d * d - radius_b * radius_b) / (2 * radius_a * d);
            const cos_t2 = (radius_b * radius_b + d * d - radius_a * radius_a) / (2 * radius_b * d);
            
            if (cos_t1 < -1 || cos_t1 > 1 || cos_t2 < -1 || cos_t2 > 1) {
                console.log('‚ùå Valores fuera de rango para acos');
                return;
            }
            
            const t1 = Math.acos(cos_t1);
            const t2 = Math.acos(cos_t2);
            
            if (isNaN(t1) || isNaN(t2)) {
                console.log('‚ùå √Ångulos inv√°lidos');
                return;
            }
            
            // Longitud de handles para curvas Bezier
            const h = (4 * Math.tan(centerAngle / 4) / 3) * r;
            const hpi = Math.PI / 2;
            
            // Puntos de ancla (f√≥rmula original)
            const p0_anchor = [c1.x + r1 * Math.cos(ot1 + t1), c1.y + r1 * Math.sin(ot1 + t1)];
            const p1_anchor = [c2.x + r2 * Math.cos(ot2 - t2), c2.y + r2 * Math.sin(ot2 - t2)];
            const p2_anchor = [c2.x + r2 * Math.cos(ot2 + t2), c2.y + r2 * Math.sin(ot2 + t2)];
            const p3_anchor = [c1.x + r1 * Math.cos(ot1 - t1), c1.y + r1 * Math.sin(ot1 - t1)];
            
            // Puntos de control (handles)
            const p0_right = [p0_anchor[0] + h * Math.cos(ot1 + t1 - hpi), p0_anchor[1] + h * Math.sin(ot1 + t1 - hpi)];
            const p1_left = [p1_anchor[0] + h * Math.cos(ot2 - t2 + hpi), p1_anchor[1] + h * Math.sin(ot2 - t2 + hpi)];
            const p2_right = [p2_anchor[0] + h * Math.cos(ot2 + t2 - hpi), p2_anchor[1] + h * Math.sin(ot2 + t2 - hpi)];
            const p3_left = [p3_anchor[0] + h * Math.cos(ot1 - t1 + hpi), p3_anchor[1] + h * Math.sin(ot1 - t1 + hpi)];
            
            console.log('Puntos calculados:', { p0_anchor, p1_anchor, p2_anchor, p3_anchor });
            
            // Renderizar la metaball con SVG
            console.log('üé® Renderizando metaball con SVG');
            
            // Crear path SVG para la metaball
            const metaballPath = document.createElementNS(svgNS, 'path');
            
            // Construir el path data
            const pathData = [
                `M ${p0_anchor[0].toFixed(2)} ${p0_anchor[1].toFixed(2)}`, // Move to p0
                `C ${p0_right[0].toFixed(2)} ${p0_right[1].toFixed(2)}`,  // Control desde p0
                `${p1_left[0].toFixed(2)} ${p1_left[1].toFixed(2)}`,      // Control hacia p1
                `${p1_anchor[0].toFixed(2)} ${p1_anchor[1].toFixed(2)}`,   // Destino p1
                `L ${p2_anchor[0].toFixed(2)} ${p2_anchor[1].toFixed(2)}`, // L√≠nea a p2
                `C ${p2_right[0].toFixed(2)} ${p2_right[1].toFixed(2)}`,  // Control desde p2
                `${p3_left[0].toFixed(2)} ${p3_left[1].toFixed(2)}`,      // Control hacia p3
                `${p3_anchor[0].toFixed(2)} ${p3_anchor[1].toFixed(2)}`,   // Destino p3
                'Z' // Cerrar path
            ].join(' ');
            
            metaballPath.setAttribute('d', pathData);
            metaballPath.setAttribute('fill', '#ffffff');
            metaballPath.setAttribute('opacity', '1.0');
            // metaballPath.setAttribute('filter', 'url(#glow)');
            
            // Agregar borde si la conexi√≥n est√° seleccionada
            if (connection && connection.isSelected) {
                metaballPath.setAttribute('stroke', '#00ff00');
                metaballPath.setAttribute('stroke-width', '2');
            }
            
            // A√±adir al SVG
            svg.appendChild(metaballPath);
            
            console.log('‚úÖ Metaball renderizada con f√≥rmula original');
        }
        
        // Inicializar grid de c√≠rculos (SVG)
        function init() {
            const svgWidth = window.innerWidth;
            const svgHeight = window.innerHeight;
            svg.setAttribute('width', svgWidth);
            svg.setAttribute('height', svgHeight);
            
            circles = [];
            connections = [];
            selectedCircles = [];
            
            const padding = 200;
            const availableWidth = svgWidth - padding * 2;
            const availableHeight = svgHeight - padding * 2;
            
            spacing = Math.min(availableWidth / (gridCountX - 1), availableHeight / (gridCountY - 1));
            // Forzar radio m√°ximo permitido seg√∫n spacing
            const maxRadius = Math.floor(spacing / 2);
            const ballSizeSlider = document.getElementById('ballSizeSlider');
            ballSizeSlider.max = maxRadius;
            // Si el radio actual es mayor al nuevo m√°ximo, ajusta
            if (baseRadius > maxRadius) baseRadius = maxRadius;
            // Actualiza display
            document.getElementById('ballSizeValue').textContent = baseRadius;
            
            const startX = (svgWidth - (gridCountX - 1) * spacing) / 2;
            const startY = (svgHeight - (gridCountY - 1) * spacing) / 2;
            
            for (let i = 0; i < gridCountX; i++) {
                for (let j = 0; j < gridCountY; j++) {
                    const x = startX + i * spacing;
                    const y = startY + j * spacing;
                    circles.push(new Circle(x, y, baseRadius, i, j));
                }
            }
            
            updateDisplays();
        }
        
        // Funci√≥n principal de dibujo (SVG)
        function draw() {
            // Limpiar SVG
            const elementsToRemove = svg.querySelectorAll('circle, path');
            elementsToRemove.forEach(el => el.remove());
            
            // Dibujar conexiones manuales primero (para que aparezcan detr√°s)
            if (connections.length > 0) {
                console.log('Dibujando', connections.length, 'conexiones manuales en SVG');
            }
            connections.forEach((conn, index) => {
                if (conn.from.radius > 0 && conn.to.radius > 0) {
                    console.log(`Dibujando conexi√≥n SVG ${index + 1}:`, conn.from.gridI + '_' + conn.from.gridJ, '->', conn.to.gridI + '_' + conn.to.gridJ);
                    connectCircles(conn.from, conn.to, conn); // Pasar el objeto conexi√≥n
                }
            });
            
            // Dibujar c√≠rculos encima de las conexiones
            circles.forEach(circle => {
                if (circle.radius > 0) {
                    circle.draw();
                }
            });
            
            // Mostrar c√≠rculo que estamos conectando
            if (editMode === 'connect' && connectingFrom) {
                const connectingIndicator = document.createElementNS(svgNS, 'circle');
                connectingIndicator.setAttribute('cx', connectingFrom.x);
                connectingIndicator.setAttribute('cy', connectingFrom.y);
                connectingIndicator.setAttribute('r', Math.max(connectingFrom.radius + 5, 20));
                connectingIndicator.setAttribute('fill', 'none');
                connectingIndicator.setAttribute('stroke', '#ffff00');
                connectingIndicator.setAttribute('stroke-width', '3');
                connectingIndicator.setAttribute('stroke-dasharray', '5,5');
                connectingIndicator.setAttribute('opacity', '0.8');
                svg.appendChild(connectingIndicator);
            }
        }
        
        // Event listeners del SVG
        svg.addEventListener('mousemove', (event) => {
            const rect = svg.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            
            // Reset hover states
            circles.forEach(circle => circle.isHovered = false);
            
            // Find hovered circle
            const hoveredCircle = circles.find(circle => circle.contains(mouseX, mouseY));
            if (hoveredCircle) {
                hoveredCircle.isHovered = true;
            }
            
            draw();
        });
        
        svg.addEventListener('click', (event) => {
            const rect = svg.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            
            const clickedCircle = circles.find(circle => circle.contains(mouseX, mouseY));
            const clickedConnection = !clickedCircle ? getClickedConnection(mouseX, mouseY) : null;
            
            // Manejar selecci√≥n de conexiones en modo individual
            if (connectionFactorMode === 'individual' && clickedConnection && !clickedCircle) {
                if (event.ctrlKey || event.metaKey) {
                    // Multi-selecci√≥n de conexiones
                    clickedConnection.isSelected = !clickedConnection.isSelected;
                    if (clickedConnection.isSelected) {
                        if (!selectedConnections.includes(clickedConnection)) {
                            selectedConnections.push(clickedConnection);
                        }
                    } else {
                        selectedConnections = selectedConnections.filter(c => c !== clickedConnection);
                    }
                } else {
                    // Selecci√≥n simple: limpiar todo y seleccionar solo esta conexi√≥n
                    selectedConnections.forEach(c => c.isSelected = false);
                    selectedConnections = [clickedConnection];
                    clickedConnection.isSelected = true;
                }
                
                // Actualizar slider al valor de la conexi√≥n seleccionada
                if (selectedConnections.length === 1) {
                    const newValue = selectedConnections[0].connectionFactor;
                    document.getElementById('connectionSlider').value = newValue;
                    document.getElementById('connectionValue').textContent = newValue.toFixed(1);
                }
                
                draw();
                return;
            }
            
            if (!clickedCircle) return;
            
            if (editMode === 'select') {
                // Modo selecci√≥n
                if (event.ctrlKey || event.metaKey) {
                    // Multi-selecci√≥n: toggle el estado del c√≠rculo clickeado
                    clickedCircle.isSelected = !clickedCircle.isSelected;
                    if (clickedCircle.isSelected) {
                        // A√±adir a la selecci√≥n si no est√° ya
                        if (!selectedCircles.includes(clickedCircle)) {
                            selectedCircles.push(clickedCircle);
                        }
                    } else {
                        // Remover de la selecci√≥n
                        selectedCircles = selectedCircles.filter(c => c !== clickedCircle);
                    }
                } else if (event.shiftKey && selectedCircles.length > 0) {
                    // Selecci√≥n por rango (Shift+Click)
                    const firstSelected = selectedCircles[0];
                    const startI = Math.min(firstSelected.gridI, clickedCircle.gridI);
                    const endI = Math.max(firstSelected.gridI, clickedCircle.gridI);
                    const startJ = Math.min(firstSelected.gridJ, clickedCircle.gridJ);
                    const endJ = Math.max(firstSelected.gridJ, clickedCircle.gridJ);
                    
                    // Limpiar selecci√≥n actual
                    selectedCircles.forEach(c => c.isSelected = false);
                    selectedCircles = [];
                    
                    // Seleccionar rango rectangular
                    circles.forEach(circle => {
                        if (circle.gridI >= startI && circle.gridI <= endI && 
                            circle.gridJ >= startJ && circle.gridJ <= endJ) {
                            circle.isSelected = true;
                            selectedCircles.push(circle);
                        }
                    });
                } else {
                    // Selecci√≥n simple: limpiar todo y seleccionar solo este
                    selectedCircles.forEach(c => c.isSelected = false);
                    selectedCircles = [clickedCircle];
                    clickedCircle.isSelected = true;
                }
                
                updateSelectedInfo();
                
            } else if (editMode === 'connect') {
                // Modo conexi√≥n
                if (!connectingFrom) {
                    connectingFrom = clickedCircle;
                    document.getElementById('modeStatus').textContent = 'click_target_ball';

                } else if (connectingFrom !== clickedCircle) {
                    // Verificar si ya existe la conexi√≥n
                    const existingConnection = connections.find(conn => 
                        (conn.from === connectingFrom && conn.to === clickedCircle) ||
                        (conn.from === clickedCircle && conn.to === connectingFrom)
                    );
                    
                    if (!existingConnection) {
                        connections.push({ 
                            from: connectingFrom, 
                            to: clickedCircle,
                            connectionFactor: connectionFactor, // Factor individual inicial
                            isSelected: false
                        });
                        console.log('üîó Conexi√≥n creada!', connectingFrom.gridI + '_' + connectingFrom.gridJ, '<->', clickedCircle.gridI + '_' + clickedCircle.gridJ, 'Total:', connections.length);
                    }
                    connectingFrom = null;
                    document.getElementById('modeStatus').textContent = 'connect_balls';

                    updateDisplays();
                } else {
                    connectingFrom = null;
                    document.getElementById('modeStatus').textContent = 'connect_balls';

                }
            }
            
            draw();
        });
        
        // Funciones de actualizaci√≥n de displays
        function updateSelectedInfo() {
            const ballSizeSlider = document.getElementById('ballSizeSlider');
            
            if (selectedCircles.length === 0) {
                ballSizeSlider.disabled = true;
                ballSizeSlider.value = 30;
            } else if (selectedCircles.length === 1) {
                ballSizeSlider.disabled = false;
                ballSizeSlider.value = selectedCircles[0].radius;
            } else {
                // M√∫ltiples seleccionadas
                const avgSize = Math.round(selectedCircles.reduce((sum, c) => sum + c.radius, 0) / selectedCircles.length);
                ballSizeSlider.value = avgSize;
                ballSizeSlider.disabled = false;
            }
            
            updateBallSizeDisplay();
        }
        
        function updateDisplays() {
            document.getElementById('connectionValue').textContent = connectionFactor.toFixed(1);
            document.getElementById('gridSizeValue').textContent = `${gridCountX}√ó${gridCountY} = ${gridCountX * gridCountY}`;
            
            // Actualizar contador de conexiones con informaci√≥n de selecci√≥n
            let connectionsText = `${connections.length} connections`;
            if (connectionFactorMode === 'individual' && selectedConnections.length > 0) {
                connectionsText += ` (${selectedConnections.length} selected)`;
            }
            document.getElementById('connectionsCount').textContent = connectionsText;
            
            updateSelectedInfo();
        }
        
        function updateBallSizeDisplay() {
            const value = document.getElementById('ballSizeSlider').value;
            document.getElementById('ballSizeValue').textContent = value;
        }
        
        // Event Listeners para controles
        document.getElementById('selectMode').addEventListener('click', () => {
            editMode = 'select';
            connectingFrom = null;
            document.getElementById('selectMode').classList.add('active');
            document.getElementById('connectMode').classList.remove('active');
            document.getElementById('modeStatus').textContent = 'select_balls';

            draw();
        });
        
        document.getElementById('connectMode').addEventListener('click', () => {
            editMode = 'connect';
            connectingFrom = null;
            document.getElementById('connectMode').classList.add('active');
            document.getElementById('selectMode').classList.remove('active');
            document.getElementById('modeStatus').textContent = 'connect_balls';
            draw();
        });
        
        // Event listeners para Connection Factor Mode Toggle
        document.getElementById('globalMode').addEventListener('click', () => {
            connectionFactorMode = 'global';
            selectedConnections = []; // Limpiar selecciones
            connections.forEach(conn => conn.isSelected = false);
            document.getElementById('globalMode').classList.add('active');
            document.getElementById('individualMode').classList.remove('active');
            document.getElementById('connectionModeStatus').textContent = 'affects_all_connections';
            draw();
        });
        
        document.getElementById('individualMode').addEventListener('click', () => {
            connectionFactorMode = 'individual';
            document.getElementById('individualMode').classList.add('active');
            document.getElementById('globalMode').classList.remove('active');
            document.getElementById('connectionModeStatus').textContent = 'click_connections_to_select';
            draw();
        });
        
        document.getElementById('ballSizeSlider').addEventListener('input', (event) => {
            const newSize = parseInt(event.target.value);
            selectedCircles.forEach(circle => {
                circle.radius = newSize;
            });
            updateBallSizeDisplay();
            draw();
        });
        
        document.getElementById('connectionSlider').addEventListener('input', (event) => {
            const newFactor = parseFloat(event.target.value);
            
            if (connectionFactorMode === 'global') {
                // Modo global: actualizar factor global y todas las conexiones
                connectionFactor = newFactor;
                connections.forEach(conn => {
                    conn.connectionFactor = newFactor;
                });
            } else {
                // Modo individual: actualizar solo conexiones seleccionadas
                if (selectedConnections.length > 0) {
                    selectedConnections.forEach(conn => {
                        conn.connectionFactor = newFactor;
                    });
                } else {
                    // Si no hay conexiones seleccionadas, actualizar el global para nuevas conexiones
                    connectionFactor = newFactor;
                }
            }
            
            updateDisplays();
            draw();
        });
        
        document.getElementById('clearConnections').addEventListener('click', () => {
            connections = [];
            updateDisplays();
            draw();
        });
        
        document.getElementById('resetAll').addEventListener('click', () => {
            circles.forEach(circle => {
                circle.radius = baseRadius;
                circle.isSelected = false;
            });
            selectedCircles = [];
            connections = [];
            connectingFrom = null;
            updateDisplays();
            draw();
        });
        
        // Event listeners para grid size
        ['gridRowsInput', 'gridColsInput'].forEach(id => {
            document.getElementById(id).addEventListener('input', (event) => {
                const newValue = parseInt(event.target.value);
                if (newValue >= 3 && newValue <= 12) {
                    if (id === 'gridRowsInput') gridCountY = newValue;
                    else gridCountX = newValue;
                    init();
                }
            });
        });
        
        // === CONTROLES AVANZADOS DE MOUSE ===
        let spacePressed = false;
        let ctrlPressed = false;
        
        // Detectar teclas
        document.addEventListener('keydown', (event) => {
            if (event.code === 'Space') {
                spacePressed = true;
                event.preventDefault();
            }
            if (event.ctrlKey || event.metaKey) {
                ctrlPressed = true;
                
                // Ctrl+A / Cmd+A = Select All
                if (event.code === 'KeyA' && editMode === 'select') {
                    event.preventDefault();
                    selectedCircles.forEach(c => c.isSelected = false);
                    selectedCircles = [...circles];
                    circles.forEach(circle => circle.isSelected = true);
                    updateSelectedInfo();
                    draw();
                }
            }
            
            // Escape = Deselect All
            if (event.code === 'Escape') {
                selectedCircles.forEach(c => c.isSelected = false);
                selectedCircles = [];
                connectingFrom = null;
                updateSelectedInfo();
                draw();
            }
        });
        
        document.addEventListener('keyup', (event) => {
            if (event.code === 'Space') {
                spacePressed = false;
                event.preventDefault();
            }
            if (!event.ctrlKey && !event.metaKey) {
                ctrlPressed = false;
            }
        });
        
        // Scroll para control de valores
        svg.addEventListener('wheel', (event) => {
            event.preventDefault();
            
            const rect = svg.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            const hoveredCircle = circles.find(circle => circle.contains(mouseX, mouseY));
            
            if (hoveredCircle) {
                const delta = -event.deltaY / 100; // Normalizar scroll
                
                if (editMode === 'select') {
                    // En modo select: scroll ajusta tama√±o de la bola
                    if (spacePressed || hoveredCircle.isSelected) {
                        
                        if (selectedCircles.length > 1 && hoveredCircle.isSelected) {
                            // Si hay m√∫ltiples bolas seleccionadas y hacemos scroll sobre una de ellas,
                            // cambiar el tama√±o de TODAS las seleccionadas
                            const deltaSize = delta * 3;
                            selectedCircles.forEach(circle => {
                                const newRadius = Math.max(0, Math.min(100, circle.radius + deltaSize));
                                circle.radius = newRadius;
                            });
                            
                            // Actualizar slider con el valor de la bola sobre la que hicimos hover
                            document.getElementById('ballSizeSlider').value = hoveredCircle.radius;
                            updateBallSizeDisplay();
                            
                        } else {
                            // Comportamiento normal para una sola bola
                            const newRadius = Math.max(0, Math.min(100, hoveredCircle.radius + delta * 3));
                            hoveredCircle.radius = newRadius;
                            
                            // Actualizar slider si est√° seleccionada
                            if (hoveredCircle.isSelected) {
                                document.getElementById('ballSizeSlider').value = newRadius;
                                updateBallSizeDisplay();
                            }
                        }
                        draw();
                    }
                } else if (editMode === 'connect') {
                    // En modo connect: scroll ajusta connection factor
                    const newFactor = Math.max(0.5, Math.min(5.0, connectionFactor + delta * 0.1));
                    connectionFactor = newFactor;
                    document.getElementById('connectionSlider').value = connectionFactor;
                    updateDisplays();
                    draw();
                }
            }
        });
        
        // Click mejorado con teclas modificadoras
        svg.addEventListener('click', (event) => {
            const rect = svg.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            const clickedCircle = circles.find(circle => circle.contains(mouseX, mouseY));
            
            if (!clickedCircle) return;
            
            // Space + Click = Selecci√≥n r√°pida (sin cambiar modo)
            if (spacePressed) {
                clickedCircle.isSelected = !clickedCircle.isSelected;
                if (clickedCircle.isSelected) {
                    if (!selectedCircles.includes(clickedCircle)) {
                        selectedCircles.push(clickedCircle);
                    }
                } else {
                    selectedCircles = selectedCircles.filter(c => c !== clickedCircle);
                }
                updateSelectedInfo();
                draw();
                return;
            }
            
            // Ctrl/Cmd + Click en modo connect = Conexi√≥n r√°pida
            if (ctrlPressed && editMode === 'select') {
                // Cambiar temporalmente a modo connect
                if (!connectingFrom) {
                    connectingFrom = clickedCircle;
                    document.getElementById('modeStatus').textContent = 'quick_connect_mode';
                } else if (connectingFrom !== clickedCircle) {
                    const existingConnection = connections.find(conn => 
                        (conn.from === connectingFrom && conn.to === clickedCircle) ||
                        (conn.from === clickedCircle && conn.to === connectingFrom)
                    );
                    
                    if (!existingConnection) {
                        connections.push({ 
                            from: connectingFrom, 
                            to: clickedCircle,
                            connectionFactor: connectionFactor,
                            isSelected: false
                        });
                    }
                    connectingFrom = null;
                    document.getElementById('modeStatus').textContent = 'select_balls';
                    updateDisplays();
                } else {
                    connectingFrom = null;
                    document.getElementById('modeStatus').textContent = 'select_balls';
                }
                draw();
                return;
            }
            
            // El resto del c√≥digo de click normal continuar√° despu√©s
        }, true); // useCapture = true para capturar antes que el evento normal
        
        // Funci√≥n para descargar SVG
        async function downloadSVG() {
            try {
                // Crear una copia del SVG para descarga
                const svgClone = svg.cloneNode(true);
                
                // Asegurar namespaces y atributos correctos
                svgClone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
                svgClone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
                svgClone.setAttribute('version', '1.1');
                
                // Serializar el SVG
                const svgData = new XMLSerializer().serializeToString(svgClone);
                const svgWithXML = '<?xml version="1.0" encoding="UTF-8"?>\n' + svgData;
                
                // Generar nombre de archivo
                const timestamp = new Date().toISOString().slice(0, 16).replace(/[:-]/g, '');
                const filename = `metaballs-svg-editor-${gridCountX}x${gridCountY}-${connections.length}conn-${timestamp}.svg`;
                
                // Descarga usando File System Access API si est√° disponible
                try {
                    if ('showSaveFilePicker' in window) {
                        const fileHandle = await window.showSaveFilePicker({
                            suggestedName: filename,
                            types: [{
                                description: 'SVG files',
                                accept: { 'image/svg+xml': ['.svg'] }
                            }]
                        });
                        const writable = await fileHandle.createWritable();
                        await writable.write(svgWithXML);
                        await writable.close();
                        console.log('‚úÖ SVG descargado via File System API:', filename);
                    } else {
                        // Descarga tradicional
                        const blob = new Blob([svgWithXML], { type: 'image/svg+xml;charset=utf-8' });
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        link.download = filename;
                        link.style.display = 'none';
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(url);
                        console.log('‚úÖ SVG descargado via m√©todo tradicional:', filename);
                    }
                } catch (downloadError) {
                    // Fallback: abrir en nueva ventana
                    const dataUrl = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgWithXML);
                    window.open(dataUrl, '_blank');
                    console.log('‚ö†Ô∏è SVG abierto en nueva ventana como fallback');
                }
                
            } catch (error) {
                console.error('‚ùå Error generando SVG:', error);
                alert('Error generando SVG. Revisa la consola para m√°s detalles.');
            }
        }
        
        // Event listener para descarga SVG
        document.getElementById('downloadSVG').addEventListener('click', downloadSVG);
        
        // Resize handler
        window.addEventListener('resize', () => {
            init();
        });
        
        // Inicializar
        init();
        draw();

        // --- UI CONTEXTUAL Y MODAL DE AYUDA ---
        function updateUIContext() {
          // Paneles
          const ballControls = document.getElementById('ballControls');
          const connectionControls = document.getElementById('connectionControls');
          const connectionSliderBlock = document.getElementById('connectionSliderBlock');

          // Mostrar controles seg√∫n modo
          if (editMode === 'select') {
            ballControls.hidden = false;
            connectionControls.hidden = true;
          } else if (editMode === 'connect') {
            ballControls.hidden = true;
            connectionControls.hidden = false;
            // Mostrar slider solo si corresponde
            const showSlider =
              connectionFactorMode === 'global' ||
              (connectionFactorMode === 'individual' && selectedConnections.length > 0);
            connectionSliderBlock.hidden = !showSlider;
          }
        }

        // Modal de ayuda accesible
        const helpModal = document.getElementById('helpModal');
        const showHelpBtn = document.getElementById('showHelp');
        const closeHelpBtn = document.getElementById('closeHelp');

        showHelpBtn.addEventListener('click', () => {
          helpModal.style.display = 'flex';
          closeHelpBtn.focus();
        });
        closeHelpBtn.addEventListener('click', () => {
          helpModal.style.display = 'none';
          showHelpBtn.focus();
        });
        document.addEventListener('keydown', (e) => {
          if (helpModal.style.display === 'flex' && (e.key === 'Escape' || e.key === 'Esc')) {
            helpModal.style.display = 'none';
            showHelpBtn.focus();
          }
        });

        // Llama a updateUIContext en cada cambio de modo o selecci√≥n relevante
        document.getElementById('selectMode').addEventListener('click', () => {
          updateUIContext();
        });
        document.getElementById('connectMode').addEventListener('click', () => {
          updateUIContext();
        });
        document.getElementById('globalMode').addEventListener('click', () => {
          updateUIContext();
        });
        document.getElementById('individualMode').addEventListener('click', () => {
          updateUIContext();
        });
        // Llama tambi√©n tras cada selecci√≥n de conexi√≥n
        function updateSelectedConnectionsUI() {
          if (editMode === 'connect') updateUIContext();
        }
        // Hook: tras cada cambio de selectedConnections, llama a updateSelectedConnectionsUI()
        // (ya est√° en la l√≥gica de click de conexiones)

        // Llama al cargar
        updateUIContext();
    </script>
</body>
</html>
