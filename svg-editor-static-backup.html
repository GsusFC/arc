<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metaballs - SVG Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'JetBrains Mono', monospace;
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            color: #ffffff;
        }
        
        .floating-controls {
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .floating-controls h3 {
            text-shadow: 1px 1px 3px rgba(0,0,0,0.9);
        }
        
        svg {
            display: block;
            background-color: #000000;
        }
        
        .slider::-webkit-slider-thumb {
            appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 2px;
            background: #00ff00;
            cursor: pointer;
            border: 1px solid #ffffff;
            box-shadow: none;
        }
        
        .slider::-moz-range-thumb {
            height: 16px;
            width: 16px;
            border-radius: 2px;
            background: #00ff00;
            cursor: pointer;
            border: 1px solid #ffffff;
            box-shadow: none;
        }
        
        .slider {
            background: #333333 !important;
            border: 1px solid #ffffff;
        }
        
        .terminal-checkbox {
            appearance: none;
            width: 16px;
            height: 16px;
            border: 1px solid #ffffff;
            background: #000000;
            position: relative;
            cursor: pointer;
        }
        
        .terminal-checkbox:checked {
            background: #00ff00;
        }
        
        .terminal-checkbox:checked::after {
            content: '‚úì';
            position: absolute;
            top: -2px;
            left: 2px;
            color: #000000;
            font-size: 12px;
            font-weight: bold;
        }
        
        .terminal-input {
            width: 40px;
            padding: 2px;
            font-size: 12px;
            background-color: #000000;
            color: #ffffff;
            border: 1px solid #ffffff;
            text-align: center;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .context-menu {
            position: fixed;
            background: #000000;
            border: 1px solid #ffffff;
            padding: 8px 0;
            min-width: 180px;
            z-index: 1000;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            display: none;
        }
        
        .context-menu-item {
            padding: 6px 12px;
            cursor: pointer;
            color: #ffffff;
            transition: background-color 0.2s;
        }
        
        .context-menu-item:hover {
            background-color: #333333;
        }
        
        .context-menu-item.disabled {
            color: #666666;
            cursor: not-allowed;
        }
        
        .edit-mode .center-indicator {
            opacity: 1;
            transition: opacity 0.2s;
        }
        
        .center-indicator {
            opacity: 0;
            pointer-events: none;
        }
        
        .download-btn {
            background: #000000;
            border: 1px solid #00ff00;
            color: #00ff00;
            padding: 8px 16px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .download-btn:hover {
            background: #00ff00;
            color: #000000;
        }
    </style>
</head>
<body class="bg-black text-white">
    
    <!-- Version Navigation -->
    <div class="fixed top-4 right-4 z-20 flex flex-col space-y-2">
        <div class="px-3 py-2 bg-black border border-white text-center">
            <div class="text-xs text-green-400 font-medium">üé® SVG EDITOR</div>
        </div>
        
        <!-- Quick Switch -->
        <div class="flex space-x-1">
            <button onclick="window.location.href='index.html'" 
                    class="px-2 py-1 bg-black border border-blue-400 text-blue-400 text-xs hover:bg-blue-400 hover:text-black transition-all" 
                    title="Canvas Dynamic">
                üé®
            </button>
            <button onclick="window.location.href='shape-editor.html'" 
                    class="px-2 py-1 bg-black border border-yellow-400 text-yellow-400 text-xs hover:bg-yellow-400 hover:text-black transition-all" 
                    title="Shape Editor">
                üõ†Ô∏è
            </button>
            <button onclick="window.location.href='svg-editor.html'" 
                    class="px-2 py-1 bg-black border border-green-400 text-green-400 text-xs hover:bg-green-400 hover:text-black transition-all" 
                    title="SVG Editor">
                üé®
            </button>
        </div>
    </div>
    
    <!-- Controles Flotantes -->
    <div class="fixed top-4 left-4 z-10 floating-controls" style="font-family: 'JetBrains Mono', monospace;">
        <div class="flex flex-col space-y-6">
            <!-- Grid Size Control -->
            <div class="flex flex-col space-y-3">
                <h3 class="text-sm font-medium text-white">grid_size</h3>
                <div class="flex items-center space-x-3 justify-center">
                    <div class="flex flex-col items-center space-y-1">
                        <label class="text-xs text-white">rows</label>
                        <input type="number" id="gridRowsInput" min="2" max="20" value="5" class="terminal-input">
                    </div>
                    <span class="text-xs text-white mt-5">√ó</span>
                    <div class="flex flex-col items-center space-y-1">
                        <label class="text-xs text-white">cols</label>
                        <input type="number" id="gridColsInput" min="2" max="20" value="5" class="terminal-input">
                    </div>
                </div>
                <div class="text-center">
                    <span class="text-xs text-green-400 font-medium" id="gridSizeValue">5√ó5 = 25</span>
                </div>
            </div>
            
            <!-- Size Control -->
            <div class="flex flex-col space-y-3">
                <h3 class="text-sm font-medium text-white">size_max</h3>
                <div class="flex items-center space-x-3">
                    <span class="text-xs text-white">0.3</span>
                    <input type="range" id="sizeSlider" min="0.3" max="1.5" step="0.1" value="0.8" class="flex-1 h-2 appearance-none cursor-pointer slider">
                    <span class="text-xs text-white">1.5</span>
                </div>
                <div class="text-center">
                    <span class="text-xs text-green-400 font-medium" id="sizeValue">0.8</span>
                </div>
            </div>
            
            <!-- Connection Control -->
            <div class="flex flex-col space-y-3">
                <h3 class="text-sm font-medium text-white">connection_factor</h3>
                <div class="flex items-center space-x-3">
                    <span class="text-xs text-white">0.5</span>
                    <input type="range" id="connectionSlider" min="0.5" max="2.0" step="0.1" value="1.0" class="flex-1 h-2 appearance-none cursor-pointer slider">
                    <span class="text-xs text-white">2.0</span>
                </div>
                <div class="text-center">
                    <span class="text-xs text-green-400 font-medium" id="connectionValue">1.0</span>
                </div>
            </div>
            
            <!-- Orthogonal Mode -->
            <div class="flex flex-col space-y-3">
                <h3 class="text-sm font-medium text-white">orthogonal_mode</h3>
                <div class="flex items-center space-x-3">
                    <input type="checkbox" id="orthogonalToggle" class="terminal-checkbox">
                    <label for="orthogonalToggle" class="text-sm text-white cursor-pointer">[x] horizontal_vertical_only</label>
                </div>
                <div class="text-center">
                    <span class="text-xs text-green-400 font-medium" id="orthogonalStatus">all_directions</span>
                </div>
            </div>
            
            <!-- Influence Centers -->
            <div class="flex flex-col space-y-3">
                <h3 class="text-sm font-medium text-white">influence_centers</h3>

                <div id="centersStatus" class="text-xs text-green-400">
                    <div>Center 1: None</div>
                    <div>Center 2: None</div>
                    <div>Center 3: None</div>
                </div>
            </div>
            
            <!-- Download Button -->
            <div class="flex flex-col space-y-3">
                <button id="downloadBtn" class="download-btn">üì• Download SVG</button>
                <div id="downloadStatus" class="text-xs text-center" style="min-height: 16px;"></div>
            </div>
        </div>
    </div>
    
    <!-- SVG Container -->
    <svg id="circleSvg" width="100%" height="100%"></svg>
    
    <!-- Context Menu -->
    <div id="contextMenu" class="context-menu">
        <div class="context-menu-item" data-action="center1">Set as Center 1</div>
        <div class="context-menu-item" data-action="center2">Set as Center 2</div>
        <div class="context-menu-item" data-action="center3">Set as Center 3</div>
        <div class="context-menu-item" data-action="remove">Remove Center</div>
        <div class="context-menu-item" data-action="cancel">Cancel</div>
    </div>

    <script>
        // Global Variables
        const svg = document.getElementById('circleSvg');
        let circles = [];
        let gridCountX = 5, gridCountY = 5;
        let baseRadius, maxRadius, spacing;
        let sizeMultiplier = 0.8;
        let connectionFactor = 1.0;
        let orthogonalOnly = false;
        let editMode = false;
        let selectedCircle = null;
        let influenceCenters = { center1: null, center2: null, center3: null };

        class Circle {
            constructor(x, y, initialRadius, maxRadius, gridI, gridJ) {
                this.x = x; this.y = y;
                this.baseRadius = initialRadius;
                this.maxRadius = maxRadius;
                this.radius = initialRadius;
                this.gridI = gridI; this.gridJ = gridJ;
                this.centerType = null;
                this.influenceRange = 250;
            }
            
            updateRadius() {
                let maxInfluence = 0;
                Object.values(influenceCenters).forEach(center => {
                    if (center) {
                        const dx = this.x - center.x;
                        const dy = this.y - center.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < center.influenceRange) {
                            const scaleFactor = 1 - (distance / center.influenceRange);
                            maxInfluence = Math.max(maxInfluence, scaleFactor);
                        }
                    }
                });
                this.radius = this.baseRadius + (this.maxRadius - this.baseRadius) * maxInfluence;
            }
        }
        
        // Connection Functions
        function solveQuadratic(a, b, c) {
            if (Math.abs(a) < 1e-6) return b !== 0 ? [-c / b] : [];
            const d = b * b - 4 * a * c;
            if (d < 0) return [];
            const rd = Math.sqrt(d);
            return [(-b + rd) / (2 * a), (-b - rd) / (2 * a)];
        }

        function getHandleLength(angle, radius) {
            return (4 / 3) * Math.tan(angle / 4) * radius;
        }

        function areOrthogonalNeighbors(c1, c2) {
            const di = Math.abs(c1.gridI - c2.gridI);
            const dj = Math.abs(c1.gridJ - c2.gridJ);
            return (di === 1 && dj === 0) || (di === 0 && dj === 1);
        }

        function connectCircles(c1, c2) {
            if (orthogonalOnly && !areOrthogonalNeighbors(c1, c2)) return null;
            
            const r1 = Math.max(0, c1.radius);
            const r2 = Math.max(0, c2.radius);
            const d = Math.sqrt((c1.x - c2.x) ** 2 + (c1.y - c2.y) ** 2);

            if (d > (r1 + r2) * connectionFactor || d <= Math.abs(r1 - r2)) return null;

            const centerAngle = Math.PI / 2;
            const cos_ca = Math.cos(centerAngle);
            const a_eq = 2 - 2 * cos_ca;
            const b_eq = 2 * (1 - cos_ca) * (r1 + r2);
            const c_eq = r1 * r1 + r2 * r2 - d * d - 2 * r1 * r2 * cos_ca;
            
            const solutions = solveQuadratic(a_eq, b_eq, c_eq);
            const r = solutions.filter(s => s > 0).reduce((min, s) => Math.min(min, s), Infinity);
            if (!isFinite(r)) return null;

            const a = r1 + r;
            const b = r2 + r;
            const cos_t1 = Math.max(-1, Math.min(1, (a * a + d * d - b * b) / (2 * a * d)));
            const cos_t2 = Math.max(-1, Math.min(1, (b * b + d * d - a * a) / (2 * b * d)));
            const t1 = Math.acos(cos_t1);
            const t2 = Math.acos(cos_t2);
            const angle_o1_o2 = Math.atan2(c2.y - c1.y, c2.x - c1.x);

            const p1 = { x: c1.x + r1 * Math.cos(angle_o1_o2 + t1), y: c1.y + r1 * Math.sin(angle_o1_o2 + t1) };
            const p2 = { x: c2.x + r2 * Math.cos(angle_o1_o2 + Math.PI - t2), y: c2.y + r2 * Math.sin(angle_o1_o2 + Math.PI - t2) };
            const p3 = { x: c2.x + r2 * Math.cos(angle_o1_o2 + Math.PI + t2), y: c2.y + r2 * Math.sin(angle_o1_o2 + Math.PI + t2) };
            const p4 = { x: c1.x + r1 * Math.cos(angle_o1_o2 - t1), y: c1.y + r1 * Math.sin(angle_o1_o2 - t1) };

            const handleLength = getHandleLength(centerAngle, r);
            const hpi = Math.PI / 2;
            const angle_p1_h = angle_o1_o2 + t1 - hpi;
            const angle_p2_h = angle_o1_o2 + Math.PI - t2 + hpi;
            const angle_p3_h = angle_o1_o2 + Math.PI + t2 - hpi;
            const angle_p4_h = angle_o1_o2 - t1 + hpi;

            const cp1 = { x: p1.x + handleLength * Math.cos(angle_p1_h), y: p1.y + handleLength * Math.sin(angle_p1_h) };
            const cp2 = { x: p2.x + handleLength * Math.cos(angle_p2_h), y: p2.y + handleLength * Math.sin(angle_p2_h) };
            const cp3 = { x: p3.x + handleLength * Math.cos(angle_p3_h), y: p3.y + handleLength * Math.sin(angle_p3_h) };
            const cp4 = { x: p4.x + handleLength * Math.cos(angle_p4_h), y: p4.y + handleLength * Math.sin(angle_p4_h) };

            return `M ${p1.x} ${p1.y} C ${cp1.x} ${cp1.y} ${cp2.x} ${cp2.y} ${p2.x} ${p2.y} L ${p3.x} ${p3.y} C ${cp3.x} ${cp3.y} ${cp4.x} ${cp4.y} ${p4.x} ${p4.y} Z`;
        }

        // Utility Functions
        function updateSizes() {
            maxRadius = spacing * sizeMultiplier;
            baseRadius = maxRadius / 3;
            circles.forEach(circle => {
                circle.maxRadius = maxRadius;
                circle.baseRadius = baseRadius;
            });
        }

        function updateDisplays() {
            document.getElementById('sizeValue').textContent = sizeMultiplier.toFixed(1);
            document.getElementById('connectionValue').textContent = connectionFactor.toFixed(1);
            document.getElementById('orthogonalStatus').textContent = orthogonalOnly ? 'horizontal_vertical_only' : 'all_directions';
            document.getElementById('gridSizeValue').textContent = `${gridCountX}√ó${gridCountY} = ${gridCountX * gridCountY}`;
            
            const statusEl = document.getElementById('centersStatus');
            const centers = ['center1', 'center2', 'center3'];
            statusEl.innerHTML = centers.map((centerKey, index) => {
                const center = influenceCenters[centerKey];
                if (center) {
                    return `<div>Center ${index + 1}: Row ${center.gridJ + 1}, Col ${center.gridI + 1} - Range: ${center.influenceRange}px</div>`;
                } else {
                    return `<div>Center ${index + 1}: None</div>`;
                }
            }).join('');
        }

        // SVG Functions
        function createSVGElement(tag, attributes = {}) {
            const element = document.createElementNS('http://www.w3.org/2000/svg', tag);
            Object.entries(attributes).forEach(([key, value]) => {
                element.setAttribute(key, value);
            });
            return element;
        }

        function renderSVG() {
            svg.innerHTML = '';
            circles.forEach(circle => circle.updateRadius());
            
            // Render connections
            const connections = createSVGElement('g', { id: 'connections' });
            for (let i = 0; i < circles.length; i++) {
                for (let j = i + 1; j < circles.length; j++) {
                    const pathData = connectCircles(circles[i], circles[j]);
                    if (pathData) {
                        const path = createSVGElement('path', {
                            d: pathData,
                            fill: '#ffffff',
                            stroke: '#ffffff',
                            'stroke-width': '0.5'
                        });
                        connections.appendChild(path);
                    }
                }
            }
            svg.appendChild(connections);
            
            // Render circles
            const circlesGroup = createSVGElement('g', { id: 'circles' });
            circles.forEach((circle, index) => {
                const circleEl = createSVGElement('circle', {
                    cx: circle.x,
                    cy: circle.y,
                    r: Math.max(0, circle.radius),
                    fill: '#ffffff',
                    'data-index': index
                });
                
                if (editMode && circle.centerType) {
                    const colors = { center1: '#ff0000', center2: '#0000ff', center3: '#00ff00' };
                    circleEl.setAttribute('stroke', colors[circle.centerType]);
                    circleEl.setAttribute('stroke-width', '2');
                    
                    const rangeCircle = createSVGElement('circle', {
                        cx: circle.x,
                        cy: circle.y,
                        r: circle.influenceRange,
                        fill: 'none',
                        stroke: colors[circle.centerType],
                        'stroke-width': '1',
                        'stroke-dasharray': '5,5',
                        opacity: '0.3',
                        class: 'center-indicator'
                    });
                    circlesGroup.appendChild(rangeCircle);
                    
                    const centerNumber = circle.centerType.replace('center', '');
                    const text = createSVGElement('text', {
                        x: circle.x,
                        y: circle.y + 4,
                        'text-anchor': 'middle',
                        fill: colors[circle.centerType],
                        'font-family': 'JetBrains Mono',
                        'font-size': '12',
                        'font-weight': 'bold',
                        class: 'center-indicator'
                    });
                    text.textContent = centerNumber;
                    circlesGroup.appendChild(text);
                }
                
                circlesGroup.appendChild(circleEl);
            });
            svg.appendChild(circlesGroup);
        }

        function init() {
            svg.setAttribute('width', window.innerWidth);
            svg.setAttribute('height', window.innerHeight);
            circles = [];
            const padding = 200;
            const squareSize = Math.min(window.innerWidth, window.innerHeight) - padding * 2;
            const startX = (window.innerWidth - squareSize) / 2;
            const startY = (window.innerHeight - squareSize) / 2;
            spacing = squareSize / (Math.max(gridCountX, gridCountY) - 1);
            updateSizes();
            
            for (let i = 0; i < gridCountX; i++) {
                for (let j = 0; j < gridCountY; j++) {
                    const x = startX + i * spacing;
                    const y = startY + j * spacing;
                    circles.push(new Circle(x, y, baseRadius, maxRadius, i, j));
                }
            }
            renderSVG();
        }

        // Event Handlers
        svg.addEventListener('contextmenu', (event) => {
            event.preventDefault();
            const rect = svg.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            selectedCircle = null;
            circles.forEach((circle, index) => {
                const dx = x - circle.x;
                const dy = y - circle.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance <= circle.radius) {
                    selectedCircle = index;
                }
            });
            
            if (selectedCircle !== null) {
                const circle = circles[selectedCircle];
                const menu = document.getElementById('contextMenu');
                const occupiedCenters = Object.keys(influenceCenters).filter(key => influenceCenters[key]);
                
                menu.querySelector('[data-action="center1"]').classList.toggle('disabled', occupiedCenters.includes('center1') && circle.centerType !== 'center1');
                menu.querySelector('[data-action="center2"]').classList.toggle('disabled', occupiedCenters.includes('center2') && circle.centerType !== 'center2');
                menu.querySelector('[data-action="center3"]').classList.toggle('disabled', occupiedCenters.includes('center3') && circle.centerType !== 'center3');
                menu.querySelector('[data-action="remove"]').classList.toggle('disabled', !circle.centerType);
                
                menu.style.left = event.clientX + 'px';
                menu.style.top = event.clientY + 'px';
                menu.style.display = 'block';
            }
        });

        document.getElementById('contextMenu').addEventListener('click', (event) => {
            const action = event.target.dataset.action;
            if (!action || selectedCircle === null) return;
            
            const circle = circles[selectedCircle];
            
            switch (action) {
                case 'center1':
                case 'center2':
                case 'center3':
                    if (circle.centerType) influenceCenters[circle.centerType] = null;
                    if (influenceCenters[action]) influenceCenters[action].centerType = null;
                    circle.centerType = action;
                    influenceCenters[action] = circle;
                    break;
                case 'remove':
                    if (circle.centerType) {
                        influenceCenters[circle.centerType] = null;
                        circle.centerType = null;
                    }
                    break;
            }
            
            updateDisplays();
            renderSVG();
            document.getElementById('contextMenu').style.display = 'none';
            selectedCircle = null;
        });

        svg.addEventListener('wheel', (event) => {
            if (!editMode) return;
            event.preventDefault();
            const rect = svg.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            const centerCircle = circles.find(circle => {
                if (!circle.centerType) return false;
                const dx = x - circle.x;
                const dy = y - circle.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance <= circle.radius;
            });
            
            if (centerCircle) {
                const delta = event.deltaY > 0 ? -25 : 25;
                centerCircle.influenceRange = Math.max(50, Math.min(500, centerCircle.influenceRange + delta));
                updateDisplays();
                renderSVG();
            }
        });

        document.addEventListener('keydown', (event) => {
            if (event.key === 'e' || event.key === 'E') {
                editMode = !editMode;
                document.body.classList.toggle('edit-mode', editMode);
                renderSVG();
            } else if (event.key === 'Escape') {
                document.getElementById('contextMenu').style.display = 'none';
            }
        });

        document.addEventListener('click', (event) => {
            if (!event.target.closest('#contextMenu')) {
                document.getElementById('contextMenu').style.display = 'none';
            }
        });

        document.getElementById('downloadBtn').addEventListener('click', async () => {
            const statusEl = document.getElementById('downloadStatus');
            
            try {
                // Mostrar feedback de proceso
                statusEl.innerHTML = '<span class="text-yellow-400">Preparing...</span>';
                
                // Salir del modo edici√≥n para obtener SVG limpio
                const wasInEditMode = editMode;
                if (editMode) {
                    editMode = false;
                    document.body.classList.remove('edit-mode');
                }
                
                // Forzar renderizado completo para asegurar conexiones
                circles.forEach(circle => circle.updateRadius());
                renderSVG();
                
                // Crear un clon del SVG para evitar modificar el original
                const svgClone = svg.cloneNode(true);
                
                // Asegurar que el SVG tenga el namespace correcto
                svgClone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
                svgClone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
                svgClone.setAttribute('version', '1.1');
                
                // Serializar el SVG con declaraci√≥n XML
                const svgData = new XMLSerializer().serializeToString(svgClone);
                const svgWithXML = '<?xml version="1.0" encoding="UTF-8"?>\n' + svgData;
                
                // Generar nombre de archivo con timestamp
                const timestamp = new Date().toISOString().slice(0, 16).replace(/[:-]/g, '');
                const filename = `arc-circles-${gridCountX}x${gridCountY}-${timestamp}.svg`;
                
                // M√©todo de descarga directa
                try {
                    // M√©todo 1: writeFile API (si est√° disponible)
                    if ('showSaveFilePicker' in window) {
                        const fileHandle = await window.showSaveFilePicker({
                            suggestedName: filename,
                            types: [{
                                description: 'SVG files',
                                accept: { 'image/svg+xml': ['.svg'] }
                            }]
                        });
                        const writable = await fileHandle.createWritable();
                        await writable.write(svgWithXML);
                        await writable.close();
                        
                    } else if (window.navigator && window.navigator.msSaveOrOpenBlob) {
                        // M√©todo 2: IE/Edge legacy
                        const svgBlob = new Blob([svgWithXML], { type: 'image/svg+xml;charset=utf-8' });
                        window.navigator.msSaveOrOpenBlob(svgBlob, filename);
                        
                    } else {
                        // M√©todo 3: M√©todo cl√°sico con timeout
                        const svgBlob = new Blob([svgWithXML], { type: 'image/svg+xml;charset=utf-8' });
                        const url = URL.createObjectURL(svgBlob);
                        
                        const link = document.createElement('a');
                        link.href = url;
                        link.download = filename;
                        link.target = '_blank';
                        link.rel = 'noopener noreferrer';
                        
                        // Hacer visible temporalmente para algunos navegadores
                        link.style.position = 'absolute';
                        link.style.left = '-9999px';
                        link.style.top = '-9999px';
                        
                        document.body.appendChild(link);
                        
                        // M√∫ltiples intentos de click
                        setTimeout(() => {
                            link.click();
                            
                            // Segundo intento despu√©s de un peque√±o delay
                            setTimeout(() => {
                                if (link.parentNode) {
                                    link.click();
                                }
                            }, 50);
                            
                        }, 10);
                        
                        // Limpiar despu√©s
                        setTimeout(() => {
                            if (link.parentNode) {
                                document.body.removeChild(link);
                            }
                            URL.revokeObjectURL(url);
                        }, 1000);
                    }
                } catch (fileError) {
                    console.error('Modern download failed, using fallback:', fileError);
                    
                    // Fallback: abrir en nueva ventana
                    const dataUrl = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgWithXML);
                    const newWindow = window.open(dataUrl, '_blank');
                    if (newWindow) {
                        newWindow.document.title = filename;
                        // Mostrar instrucciones al usuario
                        setTimeout(() => {
                            alert('SVG opened in new tab. Right-click and select "Save As" to download.');
                        }, 500);
                    } else {
                        // Si el popup fue bloqueado, mostrar el data URL
                        const textArea = document.createElement('textarea');
                        textArea.value = svgWithXML;
                        textArea.style.position = 'fixed';
                        textArea.style.left = '-9999px';
                        document.body.appendChild(textArea);
                        textArea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textArea);
                        
                        alert('SVG content copied to clipboard. You can paste it into a text editor and save as .svg file.');
                    }
                }
                
                // Restaurar modo edici√≥n si estaba activo
                if (wasInEditMode) {
                    setTimeout(() => {
                        editMode = true;
                        document.body.classList.add('edit-mode');
                        renderSVG();
                    }, 200);
                }
                
                // Mostrar √©xito
                statusEl.innerHTML = '<span class="text-green-400">‚úì Downloaded!</span>';
                console.log('SVG downloaded:', filename);
                
                // Limpiar mensaje
                setTimeout(() => {
                    statusEl.innerHTML = '';
                }, 3000);
                
            } catch (error) {
                console.error('Download failed:', error);
                statusEl.innerHTML = '<span class="text-red-400">‚úó Download failed</span>';
                setTimeout(() => statusEl.innerHTML = '', 4000);
            }
        });

        // Control Event Listeners
        ['gridRowsInput', 'gridColsInput'].forEach(id => {
            document.getElementById(id).addEventListener('input', (event) => {
                const newValue = parseInt(event.target.value);
                if (newValue >= 2 && newValue <= 20) {
                    if (id === 'gridRowsInput') gridCountY = newValue;
                    else gridCountX = newValue;
                    init();
                    updateDisplays();
                }
            });
        });

        ['sizeSlider', 'connectionSlider', 'orthogonalToggle'].forEach(id => {
            document.getElementById(id).addEventListener(id === 'orthogonalToggle' ? 'change' : 'input', (event) => {
                if (id === 'sizeSlider') sizeMultiplier = parseFloat(event.target.value);
                else if (id === 'connectionSlider') connectionFactor = parseFloat(event.target.value);
                else orthogonalOnly = event.target.checked;
                
                if (id === 'sizeSlider') updateSizes();
                renderSVG();
                updateDisplays();
            });
        });

        // Initialize
        init();
        updateDisplays();
    </script>
</body>
</html>
